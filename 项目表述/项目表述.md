# 项目表述

## 1、自我介绍

面试官你好，我叫农锦丰，来自广西崇左，目前有3年的Java后端工作经验，上一家公司是xxxxxx，上一家公司主要是做xxxxxx的，

我使用的技术栈有Spring Boot、Redis、Mybatis、Mybatis-Plus、AOP、Docker、Nginx

> [!NOTE]
>
> ### 你们的团队有多少人？
>
> 我所在的项目组有10个人左右，4~5个后端，2个前端，1个测试，1个运维，1个产品经理，1个技术主管。
>
> ### 你们公司在哪？
>
> 广州市天河区吉山大灵山路xxx号



## 2、项目背景

pass



## 3、用户，日活，QPS,  TPS

我们项目总用户数约2万，日订单在500左右，日活在3000左右，我们在实际环境中测试的**峰值QPS**在80左右，TPS在高峰期大概在0.8-1.2左右，压测QPS在300左右



## 4、技术选型

我们的项目前端使用的是Vue，Ajax/Axios发送异步请求，还有ElementPlus的组件（Vant4组件库也使用过，但是最近对小程序的组件维护比较少），后端使用的是主流的Spring Boot框架

在我负责的模块中用到的技术点有Redis缓存机制



## 5、负责模块

> [!tip]
>
> ### 项目中都有什么模块？
>
> 注册、登录模块，权限校验模块，首页展示信息模块，消息模块，查找模块，个人中心模块，用户信息模块。这个项目分为小程序端和网页后台管理端，我主要参与小程序端的开发、............



我在项目中负责登录模块

> [!note]
>
> ### 你是如何对接第三方微信登录的？
>
> 首先前端调用wx.login()获取code获取临时登录凭证传给后端，我们根据这个code加上appid + appsecret请求微信接口服务获取openId，再根据openId查询数据库是否存在这个用户，不存在的话就获取手机号，先是获取AccessToken，（一般是先自行封装好的一个实现类，便于多次调用），再根据AccessToken和code请求微信接口服务获取用户的手机号码，给用户走注册，最后封装用户基本信息到JWT，返回给小程序，每次请求携带JWT来实现业务
>
> 业务请求对于多线程携带JWT的我使用ThreadLocal来保证正确获取用户的信息，保证线程安全
>
> > [!tip]
> >
> > 我们的微信登录采用了静默授权的方式：
> >
> > 首先，前端调用wx.login()获取临时登录凭证code，然后传给后端。
> > 后端拿到code后，结合配置的appid和appsecret，调用微信的code2Session接口获取用户的openid和session_key。
> > 接着，根据openid查询数据库判断用户是否已存在，如果不存在就创建新用户记录。
> >
> > 对于需要手机号的场景，我们采用了额外的授权流程：
> > 用户点击"获取手机号"按钮触发wx.getPhoneNumber()，获得包含加密手机号信息的code。
> > 后端使用之前获取的session_key对加密的手机号数据进行解密，得到真实手机号完成用户注册。
> >
> > 最后，将用户信息封装到JWT token中返回给小程序，后续的业务请求都携带这个token。
> >
> > 在多线程环境下，我使用ThreadLocal来存储当前线程的用户信息，确保在同一个请求处理过程中能正确获取到当前用户数据，避免线程间的数据混乱。具体是在拦截器中解析JWT后将用户信息存入ThreadLocal，业务方法中通过工具类获取，请求结束后及时清理避免内存泄漏。
>
> 
>
> 
>
> ### Redis和JVM缓存
>
> 在查询~~某某读多写少的页面~~时，我通过使用JVM缓存还有Redis缓解查询Mysql数据库的压力，提高查询效率。在用户发起请求之后，是先去缓存查看是否有数据，有的话直接返回给前端；JVM缓存没有的话在查询Redis，Redis有的话直接返回给前端，并且将数据写入JVM缓存；Redis没有的话，就去查数据库，然后把有的数据写入缓存和Redis。
>
> > [!tip]
> >
> > 针对首页展示信息和医院科室列表这些读多写少的数据，我设计了一个二级缓存架构来优化查询性能。
> >
> > 具体的查询流程是这样的：
> > 首先检查JVM本地缓存（我们使用Caffeine实现），如果命中直接返回数据。
> > 如果JVM缓存没有，再查询Redis分布式缓存，命中的话返回数据并同时写入JVM缓存。
> > 如果Redis也没有，最后查询MySQL数据库，查到数据后同时写入Redis和JVM缓存。
> >
> > 这样设计的好处是：
> > JVM缓存响应最快，但只能单机使用；Redis可以多节点共享，但有网络开销；
> > 通过这种二级缓存结构，常用数据基本都能在JVM层面解决，大大减少了数据库压力。
> >
> > 在缓存管理方面，JVM缓存设置了5分钟过期时间，Redis缓存设置30分钟过期。
> > 当后台数据发生更新时，会主动清除对应的Redis缓存，JVM缓存则通过TTL自然过期，
> > 这样既保证了数据的相对实时性，又避免了频繁的缓存同步操作。
>
> 
>
> 
>
> ### 你是怎么实现图片上传功能的？
>
> 我还对接过OSS实现图片上传功能，前端创建form表单，设置enctype="multipart/form-data"属性，通过input标签选择文件，使用POST方式提交到后端。后端使用MultipartFile接收文件数据，然后通过配置好的OSS SDK将文件上传到阿里云对象存储，最后返回文件的访问URL给前端。
>
> > [!tip]
> >
> > 还有一种在前端上传的实现方式，这种方式可以减少后端的带宽压力
> >
> > 后端提供一个接口生成OSS的临时签名和上传凭证，前端获取这些信息后直接向OSS发起上传请求，不经过后端服务器中转。这种方式的好处是可以减少后端服务器的带宽压力和处理时间，特别是在大文件或高并发上传场景下效果明显。
> >
> > 
> >
> > 在实际项目中，我们主要采用第一种方案，因为可以更好地做安全控制和业务处理，比如图片压缩、添加水印、病毒扫描等。 第二种方案我们在处理用户头像上传时使用过，确实能明显减少服务器带宽压力，特别是在用户量大的时候效果比较明显。 两种方案我都配置了上传失败的重试机制，以及文件重复性校验（通过MD5避免重复上传相同文件）。
>
> 
>
> ### ~~缓存更新策略 / 数据同步机制 / 最终一致性方案~~
>
> 针对预约时间段查询这种高查询、低频更新的场景，我设计了一套缓存同步机制来优化性能。
>
> 具体场景是这样的：用户查询可预约时间时需要一次性返回21个时间段的可预约次数，这个接口调用很频繁，但预约数据的更新相对较少。
>
> 我的解决方案采用了最终一致性的设计思路：
> 首先，在数据库层面设置触发器监听预约表的数据变化；
> 然后，当有预约数据发生变更时，触发器会发送消息到RabbitMQ消息队列；
> 接着，消费者异步处理这些消息，更新Redis中的缓存数据；
> 最后，还配置了定时任务每5分钟进行一次全量数据同步，作为兜底机制。
>
> 通过这套机制，查询性能得到了显著提升，响应时间从原来直接查询数据库的200ms左右，降低到了缓存查询的20ms以内，QPS也有了明显的提升。
>
> 当然这个方案也有权衡，就是牺牲了强一致性，用户看到的可预约数可能会有几秒钟的延迟更新，但对于预约这种业务场景来说是可以接受的。如果遇到突发高并发的情况，可能还需要增加一些额外的限流和降级措施。
>
> 
>
> ### 阿里云、华为云IoT物联网设备接入
>
> 手环/手表监测等，设备管理，
>
> [华为云IotDA实例设备管理接口文档](https://support.huaweicloud.com/api-iothub/iot_06_v5_0003.html)，根据API文档，





## 6、核心模块





## 、AI相关

### .1 你是什么时候开始接触AI的？

我是从23年前半年开始使用OpenAI的ChatGPT3.5/4，后来接触了其他大模型，如Claude系列，DeepSeek系列，Gemini系列，Grok系列，通义千问系列等等，对AI的使用，以及API的对接都比较熟悉



### .2 你是怎么接入AI的？





> 1.在设计开发过程中，有遇到过什么难点和挑战吗？
>
> 2.介绍一个解决过的线上问题，是怎么定位问题？怎么解决？采取什么措施避免以后再发生？
>
> 3.核心接口的高峰和平均QPS是多少、用户表和订单表有多少数据等指标参数
>
> 4.项目的亮点是什么？
>
> 5.项目组人员组成
>
> 6.整个系统总共多少张表？有哪些表？