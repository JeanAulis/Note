[toc]

# `toBean()`和`copyProperties()`的主要区别

在于**使用方式**和**对象创建**：

## 使用方式对比

### BeanUtil.toBean()

// 浅拷贝

```java
// 一步完成：创建对象 + 属性复制
NursingProjectVo vo = BeanUtil.toBean(entity, NursingProjectVo.class);
```

### BeanUtils.copyProperties()

```java
// 两步完成：先创建对象，再复制属性
NursingProjectVo vo = new NursingProjectVo();
BeanUtils.copyProperties(entity, vo);
```

## 核心区别

### 1. **对象创建**

- **toBean()**：内部自动创建目标对象实例
- **copyProperties()**：需要手动创建目标对象

### 2. **参数顺序**

```java
// toBean：源对象在前，目标类型在后
BeanUtil.toBean(源对象, 目标类.class)

// copyProperties：源对象在前，目标对象在后  
BeanUtils.copyProperties(源对象, 目标对象)
```

### 3. **返回值**

- **toBean()**：返回转换后的新对象
- **copyProperties()**：无返回值（void），直接修改目标对象

### 4. **使用场景**

**toBean()适合**：

```java
// 查询场景：Entity → VO
public NursingProjectVo getById(Long id) {
    NursingProject entity = mapper.selectById(id);
    return BeanUtil.toBean(entity, NursingProjectVo.class); // 创建新VO
}
```

**copyProperties()适合**：

```java
// 更新场景：VO → Entity
public void update(NursingProjectVo vo) {
    NursingProject entity = mapper.selectById(vo.getId()); // 已存在的对象
    BeanUtils.copyProperties(vo, entity); // 更新现有对象
    mapper.updateById(entity);
}
```

## 完整对比

| 特性         | toBean()   | copyProperties() |
| ------------ | ---------- | ---------------- |
| **对象创建** | 自动创建   | 手动创建         |
| **代码行数** | 1行        | 2行              |
| **返回值**   | 新对象     | void             |
| **适用场景** | 创建新对象 | 更新现有对象     |
| **链式调用** | 支持       | 不支持           |

## 实际应用选择

### 新增场景

```java
// 使用toBean()
@Override
public void add(NursingProjectVo vo) {
    NursingProject entity = BeanUtil.toBean(vo, NursingProject.class);
    entity.setCreateTime(LocalDateTime.now()); // 设置额外字段
    mapper.insert(entity);
}
```

### 更新场景

```java
// 使用copyProperties()
@Override  
public void update(NursingProjectVo vo) {
    NursingProject entity = mapper.selectById(vo.getId());
    BeanUtils.copyProperties(vo, entity); // 保留数据库原有字段
    entity.setUpdateTime(LocalDateTime.now());
    mapper.updateById(entity);
}
```

## 性能考虑

两者底层都使用反射机制，性能相近。在高频调用场景下，建议使用MapStruct等编译时工具。

**选择原则**：

- 需要**创建新对象**时用`toBean()`
- 需要**更新现有对象**时用`copyProperties()`
- 追求**代码简洁性**时优先用`toBean()`

**核心区别**：`toBean()`是**工厂模式**（创建并返回新对象），`copyProperties()`是**修改器模式**（修改现有对象）。







# MyBatis XML 映射归档总结

## 1. `<resultMap>` 的使用场景

**作用**：对复杂查询结果进行自定义映射到 Java 实体类。

**使用 `<resultMap>` 的场景**：

1. **字段名和属性名不一致**（没有开启 `mapUnderscoreToCamelCase`）
2. **结果映射到嵌套对象**（对象属性）
3. **一对多 / 多对多关系映射**（集合属性）
4. **主键特殊映射、构造器映射、类型转换等复杂自定义映射**

**普通单表查询且字段名与属性名一致**可直接使用 `resultType`。

------

## 2. `<association>` —— 一对一映射

**作用**：把查询结果的一部分列映射到实体类的 **嵌套对象属性**（单个对象）。

**适用场景**：

- 实体类中有对象类型属性
- SQL 查询结果包含该对象的字段
- 一对一关系

**示例类与 SQL**：

```java
class User {
    private Integer id;
    private String username;
    private Address address; // 嵌套对象
}

class Address {
    private String city;
    private String street;
}
```

SQL 查询：

```sql
select u.id, u.username, a.city, a.street
from user u
join address a on u.address_id = a.id;
```

XML 映射：

```xml
<resultMap id="userMap" type="com.example.User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <association property="address" javaType="com.example.Address">
        <result property="city" column="city"/>
        <result property="street" column="street"/>
    </association>
</resultMap>
```

> 备注：如果只是字段名和属性名不一致，可通过 SQL 别名 + `resultType` 解决，但嵌套对象仍需 `<association>`。

------

## 3. `<collection>` —— 一对多映射

**作用**：把查询结果映射到实体类的 **集合属性**（List/Set）。

**适用场景**：

- 实体类中有集合属性
- 数据库是一对多或多对多关系
- SQL 查询返回多条记录需要组装到同一个父对象的集合中

**示例类与 SQL**：

```java
class User {
    private Integer id;
    private String username;
    private List<Role> roles; // 一对多集合
}

class Role {
    private Integer id;
    private String roleName;
}
```

SQL 查询：

```sql
select u.id, u.username, r.id as role_id, r.role_name
from user u
join user_role ur on u.id = ur.user_id
join role r on ur.role_id = r.id;
```

XML 映射：

```xml
<resultMap id="userWithRolesMap" type="com.example.User">
    <id property="id" column="id"/>
    <result property="username" column="username"/>
    <collection property="roles" ofType="com.example.Role">
        <id property="id" column="role_id"/>
        <result property="roleName" column="role_name"/>
    </collection>
</resultMap>
```

------

## 4. `<association>` vs `<collection>` 对比

| 特性          | `<association>`     | `<collection>`       |
| ------------- | ------------------- | -------------------- |
| 映射对象类型  | 单个对象            | 集合对象（List/Set） |
| 数据库关系    | 一对一 / 单对象嵌套 | 一对多 / 多对多      |
| Java 属性类型 | 单个实体类          | 集合类型（List/Set） |
| XML 标签位置  | `<association>`     | `<collection>`       |
| 使用场景示例  | `Address address`   | `List<Role> roles`   |

**使用原则**：

- 对象属性是单个对象 → `<association>`
- 对象属性是集合 → `<collection>`
- 一条 SQL 查询既有单对象又有集合 → 可同时使用 `<association>` 和 `<collection>`

------

## 5. 起别名与 `<association>` / `<collection>`

- **字段名与属性名不一致**：可通过 SQL 别名 + `resultType` 解决
- **嵌套对象 / 集合**：别名无法代替 `<association>` 或 `<collection>`，必须用 `<resultMap>`

------

这份归档总结覆盖了：

- `<resultMap>` 使用场景
- `<association>` 用法及示例
- `<collection>` 用法及示例（包括你提到的 `User -> List<Role>` 场景）
- `<association>` vs `<collection>` 对比表
- 起别名与映射的关系



