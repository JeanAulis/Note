[toc]

---

## 1. 说一下悲观锁和乐观锁的区别？还有行锁和表锁的区别？什么时候会上表锁？什么时候会上行锁？

### 悲观锁和乐观锁的区别？

从名字上面就能大概了解这两个锁的思想，他们两个的主要区别体现在对数据冲突的预期和处理方式，**悲观锁**的核心思想是认为数据总会被修改，所以在读取或者增删改数据的时候，先上锁再操作，阻塞其他事务对数据的修改；而**乐观锁**则是认为数据一般不会被修改，所以等提交更新的时候再检查数据是否被别的事务修改，有冲突就回滚或者重试。

再从并发性能方面来说，悲观锁适合写操作频繁，冲突概率高的业务，但是会导致阻塞，降低并发性能；而乐观锁适合读多写少，冲突概率低的业务，不会产生阻塞，但是冲突时重试会带来第一定的性能开销



>  [!tip]
>
> 悲观锁和乐观锁是一种并发控制策略，常用在数据库和并发编程中。
>
> Java中synchronized和ReentrantLock都可以实现悲观锁，mysql中使用for update来实现；
>
> 乐观锁一般是通过版本号或者时间戳进行控制

>  [!tip]
>
> 主要在加锁时机不同、给出建议，使用哪种

<img src="./assets/image-20251009202725670.png" alt="image-20251009202725670" style="zoom:50%;" />

<img src="./assets/image-20251009202802546.png" alt="image-20251009202802546" style="zoom:50%;" />

<img src="./assets/image-20251009202810329.png" alt="image-20251009202810329" style="zoom:67%;" />



### 行锁和表锁的区别？什么时候会上表锁？什么时候会上行锁？

从细粒度上来说：行锁（Row Lock）只锁某一行或者几行的数据；而表锁锁住的是一整个表

从并发性能来说，行锁的并发性能高，只要操作的数据行不同，就不会阻塞等待，但是开销大（锁的数量多，加锁，释放锁，死锁检测的维护成本高）；表锁的并发性能低，一个事务对表加锁后，其他事务会被阻塞

>   [!tip]
>
>   行锁触发条件:
>
>   在行锁但查询的是没有索引条件，以及锁的行数超过阈值时，会升级为表锁



**行锁**：适合高并发、单行操作，性能更优

**表锁**：适合批量操作或低并发场景

**上锁性能**表锁性能高

<img src="./assets/image-20251009202833107.png" alt="image-20251009202833107" style="zoom:50%;" />

<img src="./assets/image-20251009202847440.png" alt="image-20251009202847440" style="zoom:50%;" />

<img src="./assets/image-20251009202855768.png" alt="image-20251009202855768" style="zoom:50%;" />



## 2. 什么是死锁？造成死锁的原因是什么？怎么解决死锁？

**死锁（Deadlock）** 是指两个或多个事务（或线程）在执行过程中，互相持有对方需要的资源，并且都在等待对方释放，最终导致这些事务永远无法继续执行下去的情况。

// TODO

常见原因有以下几种：

1. **锁的获取顺序不一致**
   - 不同事务以不同的顺序请求锁，比如事务1 先锁 `id=1` 再锁 `id=2`，事务2 反过来。
2. **事务未提交，长时间持有锁**
   - 一个事务持有资源过久，阻塞其他事务，容易导致循环等待。
3. **资源竞争激烈**
   - 多个事务频繁访问相同的数据或索引，增加死锁概率。
4. **索引缺失导致锁范围扩大**
   - 例如 InnoDB 本来可以用行锁，但因为条件没有走索引，退化成表锁，死锁概率更高。
5. **应用层逻辑导致的循环依赖**
   - 比如转账、订单更新等业务逻辑里，事务之间相互依赖。

（1）避免死锁（预防）

- **统一加锁顺序**
  - 比如规定所有事务必须先锁定 `id 小的记录`，再锁定 `id 大的记录`。
- **尽量缩短事务时间**
  - 提交要快，减少锁持有时间。
- **减少锁范围**
  - 尽量使用行锁而不是表锁。
  - 查询条件带索引，避免全表扫描导致锁住整表。
- **分解大事务**
  - 把一个大事务拆分成多个小事务，减少资源争用。

（2）检测和解除死锁

**数据库自动检测**

- InnoDB 内置死锁检测机制，会选择一个“受害事务”回滚，从而打破僵局。

**应用层处理**

- 捕获死锁异常，重新执行事务。
- 一般写成 **重试机制**（例如重试 3 次）。

<img src="./assets/image-20251009203426123.png" alt="image-20251009203426123" style="zoom:67%;" />





## 3. (待整理)项目中使用分布式锁场景及Redisson原理

// TODO

项目中分布式锁常用于：如~~电商库存扣减（防止超卖）~~直接描述，不要说“超。。。”、分布式任务调度（确保单节点执行）、缓存一致性维护（避免并发更新）。

Redisson（Java Redis客户端）底层原理：基于Redis的SETNX（或SET with NX/EX）实现分布式锁，支持可重入、红锁等。

- **获取锁**：使用Lua脚本原子执行：如果key不存在，SET key value EX ttl（设置过期时间防死锁）；可重入时用Hash结构记录线程ID和重入计数。
- **释放锁**：Lua脚本检查线程ID匹配后，递减计数或DEL key。
- **红锁**：多节点Redis集群下，获取多数节点锁（N/2+1）以防单点故障。
- **Watch Dog**：自动续期机制，守护线程每ttl/3时间续期锁，防止任务超时释放。

额外点：雪花算法需注意机器ID唯一分配（如Zookeeper），否则冲突；MySQL主从延迟可能导致读从不一致，需读主或异步补偿；Redis AOF过大需定期rewrite；Redisson锁需处理网络分区，建议结合业务重试机制，避免死锁或饥饿。





## 4. 说一下synchronized和ReentrantLock的区别？synchronized可以作用在哪些地方？锁的是什么？说一下synchronized的锁升级？可逆吗？

### `synchronized` 和 `ReentrantLock` 的区别

从来源方面来说，synchronized是JVM内置，ReentrantLock是来源于`java.util.concurrent.locks`包(JUC库)。

从公平性来说，synchronized是只支持非公平锁的，不能保证先等待的线程先获得锁，而ReentrantLock支持公平锁和非公平锁。

从中断响应的角度来说，synchronized等待锁的时候是不可中断的，ReentrantLock在等待锁时可使用`lockInterruptibly()`方法中断

synchronized在执行完同步块或者方法后会自动释放，ReentrantLock则需要使用unlock()手动释放，否则可能导致死锁

synchronized在尝试加锁的过程中，只能阻塞等待，可能会导致一直获取不到锁，变成僵尸进程，而ReentrantLock会使用tryLock()方法获取锁，这个方法有一个超时机制

> [!tip] 
>
> 条件队列（Condition Queue）是 **并发编程里与锁（Lock）配合使用的一种等待/通知机制**。它的本质是一个“等待队列”，当线程在某个条件不满足时，就会被阻塞挂起，直到被其他线程显式唤醒。



### synchronized可以用在那些地方?锁的是什么？

可以作用在实例方法中，锁的是当前对象this；也可以作用在静态方法中，锁的是类的.class对象；也可以作用在代码块中，锁的是synchronized传入的对象

### 说一下synchronized的锁升级？可逆吗？

首先是**无锁状态**：当对象刚创建的时候，此时是**无锁状态**，没有线程竞争
				↓
当有一个线程访问的时候，锁会偏向该线程，也就是**偏向锁**
				↓
当有两个线程竞争，会升级为**轻量级锁**，使用CAS自旋尝试获取锁
				↓
当自旋失败或者竞争激烈时，会升级为**重量级锁**，线程会被阻塞挂起

锁的升级是不可逆的，主要的目的是减少锁管理和性能开销

> [!tip] 
>
> 自旋（Spin）是 **多线程并发编程中的一种等待策略**，指的是线程在获取锁时，如果发现锁被占用，并不是立即阻塞挂起，而是在 **循环里反复尝试获取锁**，直到成功为止。

> [!NOte] 
>
> 并发和并行
>
> | 特性         |            并发            |            并行            |
> | :----------- | :------------------------: | :------------------------: |
> | **核心概念** |      **处理**多个任务      |    **同时执行**多个任务    |
> | **硬件要求** |        单核即可实现        |    **必须多核**或多CPU     |
> | **微观视角** |      任务**交替执行**      |      任务**同时执行**      |
> | **关注点**   | 程序的设计与结构，避免阻塞 | 程序的执行速度，提升吞吐量 |
> | **比喻**     |  一个咖啡师同时做两杯咖啡  |   两个咖啡师各做一杯咖啡   |
>
> 并行是并发的特殊情况是真正的“同时”



synchronized在JDK1.6之后性能优化明显，它俩性能接近

| 对比点       | `synchronized`                              | `ReentrantLock`                                       |
| ------------ | ------------------------------------------- | ----------------------------------------------------- |
| **用法**     | 关键字，语法层面支持，JVM 内置              | 类库实现（`java.util.concurrent.locks` 包）           |
| **可重入性** | 可重入                                      | 可重入                                                |
| **公平性**   | 非公平（不能保证先等待的线程先获得锁）      | 可选公平/非公平（构造函数可指定）                     |
| **中断响应** | 等待锁时不可中断                            | 等待锁时可中断（`lockInterruptibly()`）               |
| **尝试加锁** | 只能阻塞等待                                | 可 `tryLock()` 尝试获取锁（超时机制）                 |
| **释放**     | 自动释放（执行完同步块/方法后自动释放）     | 必须手动释放（`unlock()`），否则可能死锁              |
| **条件队列** | 没有显式条件队列，只能 `wait()/notify()`    | 支持多个条件队列（`newCondition()`）                  |
| **性能**     | JDK1.6 之后性能优化明显（偏向锁、轻量级锁） | 更灵活，但加解锁需要更多代码，性能接近 `synchronized` |



