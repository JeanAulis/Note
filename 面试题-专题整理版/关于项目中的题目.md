[toc]

---

## 1. 你在项目中哪里用到了es？用来做什么？如何保证es和数据库的一致性？

全文检索：用来做一个微商城的商品模糊查询 + 筛选查询

多维度过滤/聚合：可以根据医疗设备/耗材的类型，品牌，价格区间，以及发货地（可以排序）等进行筛选

使用query.bool.filter进行多维过滤，terms 聚合：用于分类统计（类型、品牌），range 聚合：用于数值区间统计



1. 同步双写（简单/低并发）

   - 在更新数据库事务成功后，立即同步调用 ES 的更新 API。（用异步MQ更好）

2. RabbitMQ

   - 在更新数据库事务成功后，讲消息发送到MQ来更新。



## 2. 你们项目是用哪一个垃圾收集器,为什么用这个?

在生产环境下，组长当时配置了JVM参数，据我了解，当时我们那个项目使用的是G1垃圾收集器， 因为当时我们单节点分配的内存有点大是16GB或者32GB，所以我们选择了G1垃圾收集器。

> [!tip]  
>
> 项目通常使用**G1收集器**，原因：
>
> - 适合大内存应用，堆大小通常超过4GB。
> - 提供可预测的暂停时间，满足交互式应用的低延迟需求。
> - 自动分区管理，减少内存碎片。
> - 相比CMS，G1更现代化，维护成本低。



## 3. 你的项目中出现过内存溢出吗?你是怎么排查并且解决的

服务器太拉，内存不够；全表查询，堆溢出；递归，栈溢出，方法区溢出；Excel导入导出，~~上传可以避免OOM，下载（导出）没办法避免OOM~~

首先可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置jvm参数让程序自动生成dump文件

第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析

第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

第四，找到对应的代码，通过阅读上下文的情况，进行修复即可



## 4. 项目中使用分布式锁场景及Redisson原理

> [!tip] 
>
> 波哥版：
>
> 分布式锁主要是满足多进程的互斥性，如果是简单分布式锁只需要利用redis的setnx即可实现。但是Redisson的分布式锁有更多高级特性，例如：可重入、自动续期、阻塞重试等，因此就没有选择使用setnx来实现。
>
> Redisson底层是基于Redis的hash结构来记录获取锁的线程信息，结构是这样的：key是锁名称，hasKey是线程标示，hashValue是锁重入次数。这样就可以实现锁的可重入性。
>
> 然后Redisson的分布式锁允许自定义锁的超时自动释放时间，如果没有设置或者设置的值为-1，则自动释放时间为30秒，并且会开启一个WatchDog机制。WatchDog就是一个定时任务，每隔（leaseTime/3）秒就会执行一次，会重置锁的expire时间为30秒，从而实现所的自动续期
>
> 至于阻塞重试机制，则是基于Redis的发布订阅机制。如果设置了waitTime大于0，则获取锁失败的线程会订阅一个当前锁的频道，然后等待。获取锁成功的线程在执行完业务释放锁后会向频道内发送通知，收到通知的线程会再次尝试获取锁，重复这个过程直到获取锁成功或者重试时长超过waitTime

在项目中我用过Redisson实现分布式锁，主要用于分布式环境下的资源互斥访问，比如库存扣减、分布式任务调度、缓存一致性控制等场景。

例如在库存扣减时，如果多个请求同时操作同一个商品库存，就可能出现并发修改问题。通过Redisson分布式锁可以确保同一时间只有一个线程能够执行校验和扣减逻辑，从而保证数据一致性。

Redisson相比直接用`setnx`实现的简单分布式锁，提供了更多高级特性，比如：**可重入、自动续期、阻塞重试、红锁机制等**。

它的底层原理是基于Redis的**SET NX EX命令和Lua脚本**实现的原子操作：

- **获取锁时**，Redisson会执行一段Lua脚本，如果锁不存在，就SET key并设置过期时间（防止死锁）；同时在Redis的hash结构中记录线程ID和重入次数，从而实现锁的**可重入性**。
- **释放锁时**，同样使用Lua脚本，只有锁的持有线程才能删除key；如果是可重入锁，则递减重入计数，计数为0时才真正删除key。
- **自动续期（WatchDog）机制**：当加锁线程未设置过期时间或设置为-1时，Redisson会默认设置30秒超时，并启动一个守护线程，每隔`ttl/3`秒自动续期，把锁的过期时间刷新回30秒，防止业务执行时间过长导致锁提前释放。
- **阻塞重试机制**：如果获取锁失败且设置了`waitTime`>0，Redisson会通过Redis的发布订阅机制阻塞等待，当锁释放时收到通知后重新尝试获取锁。
- **红锁机制（RedLock）**：在多Redis节点部署下，Redisson可以在N个节点中获取大多数（N/2+1）节点锁才算成功，用来保证在分布式Redis环境下的可靠性和容错性。

在底层实现上，Redisson大量使用Lua脚本保证**操作的原子性**，从而避免了分布式环境下可能出现的竞态条件。同时，它的WatchDog机制保证了锁在业务未完成前不会意外过期。

> 额外点：雪花算法需注意机器ID唯一分配（如Zookeeper)，否则冲突；MySQL主从延迟可能导致读从不一致，需读主或异步补偿；Redis AOF过大需定期rewrite；Redisson锁需处理网络分区，建议结合业务重试机制，避免死锁或饥饿。



## 5. 项目中一般用redis来做什么？做缓存的情况下那你们怎么保证数据库和缓存的的一致性？

> [!tip] 
>
> 在我的医疗设备健康平台项目中，Redis主要承担了以下几个核心作用：
>
> 首先，它被广泛用于缓存热点数据，例如用户的疗程列表、设备的最新上报数据等，这类数据读多写少、实时性要求高，使用Redis的String或Hash结构可以极大地降低数据库压力。其次，用于分布式锁控制，比如积分扣减、设备状态同步这类并发写操作，我们使用Redisson的可重入锁来防止并发导致的数据异常。第三个常见的场景是用户登录态的会话管理，通过将Token存入Redis并设置过期时间，既能实现高性能认证，又方便做单点登录。最后还有计数器类的场景，例如设备异常次数统计，用incr命令即可实现高并发安全的自增。
>
> 至于数据库与缓存一致性问题，我们采用的是典型的Cache Aside Pattern（旁路缓存模式）配合“延迟双删”策略。
>
> 具体来说，读流程是“先查缓存，缓存未命中再查数据库，查询到结果后回写缓存”；写流程则是“先删缓存，再更新数据库，最后通过延迟机制或消息队列进行二次删除”。这样做的目的在于防止写入MySQL较慢时，读线程从缓存中拿到旧数据。延迟双删的流程是：在更新数据库后，通过RabbitMQ发送一条延时消息（比如0.5到1秒后执行），再次删除对应的缓存键，保证即便在高并发场景下也能最终一致。

在我的医疗设备健康平台项目中，Redis主要用于几个场景：

- 1）作为缓存，存储热点数据如**用户疗程列表、设备最新上报数据**（用String或Hash结构），减少数据库压力；
- 2）分布式锁，比如在积分扣减时用Redisson防止并发问题；
- ~~3）消息队列的补充（如用List实现简单队列），不过我们主要用RabbitMQ；~~
- 4）会话管理，存储用户Token（用String，设置过期时间）；
- 5）计数器，如设备异常报警计数（用Incr命令）。

做缓存时，保证数据库和Redis一致性是关键，我们用的是“延迟双删”策略结合MQ异步更新。

1. **Cache Aside Pattern（旁路缓存模式）**

Cache Aside Pattern是“读先查缓存，缓存未命中查数据库并回写缓存；写操作主动更新或删除缓存”，应用层完全控制缓存的一致性策略。

2. **延迟双删**

### 具体流程：

读时先查Redis，命中返回；未命中查MySQL，查到后写入Redis。

写时（更新/删除数据）：

1. 先删Redis缓存；
2. 更新MySQL；
3. 用RabbitMQ发延迟消息（延时0.5~1秒），再删一次Redis（防止读写并发导致脏数据）。

>  [!tip] 
>
>  为什么延迟删？
>
>  因为更新MySQL可能慢，先删缓存避免旧数据被读到，延迟删处理极端情况。

3. **MQ**

>  [!tip] 
>
>  ES查不到数据的话就没必要查Mysql了
>
>  ES和Mysql的数据一致性怎么解决 -> 使用MQ
>
>  ES的数据来源于MySQL更新，通过MQ异步监听更新事件，再同步到ES索引中，从而在高并发下保持数据最终一致性。

