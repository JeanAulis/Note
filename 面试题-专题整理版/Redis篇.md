[toc]

---

## 1. 说一下缓存三兄弟/剑客分别造成的原因和解决方案？

缓存三兄弟指的是**缓存穿透、缓存击穿、缓存雪崩**，它们都是缓存失效导致数据库压力骤增的问题。

### 造成原因

- **缓存穿透**：原因是查询一个缓存和数据库不存在的数据（业务上不存在的数据），缓存中没有命中，直接穿透到数据库，导致数据库压力大。如果是恶意攻击（如大量查询不存在的键），会更严重。
- **缓存击穿**：原因是一个热点键（高并发访问）突然过期，大量请求同时打到数据库。
- **缓存雪崩**：原因是一大批键同时过期，导致请求洪峰打到数据库。

### 解决方案

- **缓存穿透**：

  - 1）缓存空值，比如查到数据库为空时，缓存一个空字符串或~~null~~(Redis没有null)，并设置短过期时间（如5分钟），避免反复穿透；（治标不治本，只能保证其中一个查询结果，如果查询不一样数据还是会出现问题）

  - 2）用布隆过滤器（Bloom Filter）在入口处过滤不存在的键，我项目中可以用它来预判用户ID是否存在；

    正常业务上，应该先查Redis，再查布隆过滤器，然后到数据库。

>  [!warning]
>
> 可能会问：
>
> - 布隆过滤器误判率怎么控制？（通过调整哈希函数数量和位数组大小，减少哈希冲突）整个重置，不能局部重置
> - bitmap做签到
> - Redis的key过期以后，布隆过滤器怎么生效的

- **缓存击穿**：

  - 1）预热缓存，在系统启动或定时任务（或者预测热点）（数据量大时可以异步线程池处理）中加载热点数据。
  - 2）用分布式锁（如Redis的Redisson）保证只有一个线程去数据库**重建缓存**，其他线程等待；
    - 重建缓存之后，释放锁，写入缓存不加锁，双重缓存检查
  - 3）设置热点键永不过期，或用逻辑过期（在值中加过期时间字段，手动检查）；  
    - 会带来其他问题，比如：用户可能会看到旧数据，如何去主动更新Redis数据
    - 缓存淘汰策略
  - ~~4）主从复制+哨兵模式，确保Redis高可用。还有分片，适合海量数据写。~~
  
- **缓存雪崩**：
  - 1）过期时间加随机值（如基数+随机数），避免同时失效；
  - 2）多级缓存（如JVM本地缓存Caffeine + Redis），本地缓存作为备份；
  - ~~3）限流降级，用Sentinel或Hystrix在高负载时熔断请求；~~（不要说）

> [!note]
>
> 布隆过滤器（Bloom Filter）底层是基于**位数组（BitMap）+ 多个哈希函数**实现的一种**高效的概率型数据结构**，用来判断某个元素是否存在于集合中。它的特点是：**判断不存在一定正确，判断存在可能误判**。
>
> 具体原理可以这样讲：
>
> 布隆过滤器底层维护一个很大的**位数组（bit array）**，初始时所有位都是0。同时定义若干个不同的**哈希函数（hash1, hash2, hash3...）**。
>
> 当我们往布隆过滤器中插入一个元素时，这个元素会依次经过多个哈希函数计算出多个哈希值，每个哈希值对应位数组中的一个位置，然后把这些位置的bit都置为1。
>
> 当我们要判断一个元素是否存在时，同样用这些哈希函数计算位置，如果发现这些位置中只要有一个bit是0，说明这个元素一定不存在；如果这些bit都为1，则“可能存在”。这里的“可能”就是布隆过滤器的误判来源——因为不同元素经过哈希后可能碰巧把相同的bit位都置为1。
>
> 误判率主要取决于两个参数：
>
> 1. 位数组的长度（越大越不容易碰撞）；
> 2. 哈希函数的数量（太少容易冲突，太多又会增加bit重叠）。
>     因此实际使用时需要根据预计存储元素数量和可接受误判率来计算合适的参数。
>
> 从**数据结构角度**讲：
>
> - **核心结构是一个超大的位数组（BitMap）**，每个位置只存储0或1；
> - **操作依赖多哈希函数**，确保分布均匀，减少冲突。
>
> 在Redis中，布隆过滤器通常通过模块（RedisBloom）或bitmaps实现。它用一个连续的二进制位空间表示整个过滤器，通过`SETBIT`和`GETBIT`操作控制bit位的设置与查询。
>
> ------
>
> 一句话总结：
>  布隆过滤器底层由**位数组+多个哈希函数**组成，通过将元素映射到多个bit位实现快速存在性判断；**0一定代表不存在，1可能代表存在**，因此它节省空间但存在一定误判率。



## 2. redis的常用数据类型有哪些？分别适用哪些场景？

Redis常用的五种核心数据类型是：**String、Hash、List、Set、Sorted Set（ZSet）**，每种类型都有典型的使用场景。

**1. String**
 最基础的数据类型，一个key对应一个value，可存储字符串、数字或二进制数据。
 常用于：缓存热点数据、存储简单对象、计数器、分布式锁、session缓存等。

**2. Hash**
 类似Java的Map结构，内部是key-value的集合，适合存储对象属性。
 常用于：存储用户信息、商品详情、配置属性等结构化数据。

**3. List**
 有序列表，按插入顺序排列，支持从两端插入和弹出。
 常用于：消息队列、任务队列、时间序列、最新动态列表等。

**4. Set**
 无序且去重的字符串集合，支持交集、并集、差集操作。
 常用于：标签系统、共同好友计算、点赞、收藏、抽奖等场景。

**5. Sorted Set（ZSet）**
 在Set的基础上，每个元素多了一个score分数，用于排序。
 常用于：排行榜、优先级队列、延时任务、时间线等。



## 3. redis为什么这么快？

基于内存的操作，避免了磁盘IO

采用单线程处理请求，这样做避免了上下文切换的开销；避免使用锁导致的锁开销和死锁问题；使用I/O多路复用，在一个线程内同时监听多个socket

![image-20251015231316767](./assets/image-20251015231316767.png)



## 4. 说一下redis的缓存淘汰策略? 说一下redis的过期策略?

### 缓存策略

缓存策略主要是用在内存不足的时候决定如何清理缓存数据。

**针对设置了过期时间的key**：

- `volatile-lru`:淘汰最近最少使用的key
- `volatile-lfu`：淘汰使用频率最低的key
- `volatile-ttl`：淘汰即将过期的key
- `volatile-random`：随机淘汰key

**针对所有key：**

- `allkeys-lru`：从所有key中淘汰最近最少使用的
- `allkeys-lfu`：从所有key中淘汰使用频率最低的
- `allkeys-random`：从所有key中随机淘汰

`noeviction`（默认策略）: 不淘汰数据,当内存不足以容纳新写入的数据时，新写入操作会报错OOM，读、删除请求可以继续服务

### 过期策略

**Redis的过期策略：** Redis采用**惰性删除**和**定期删除**相结合的方式：

**惰性删除：** 访问key时检查是否过期，如果过期就删除并返回null。这种方式节省CPU，但可能导致过期key占用内存。

**定期删除：** Redis每秒10次随机抽取一些设置了过期时间的key进行检查，发现过期就删除。这是一个渐进式过程，避免一次删除太多影响性能。







## 5. (待整理)项目中一般用redis来做什么？做缓存的情况下那你们怎么保证数据库和缓存的的一致性？

> [!tip]
>
> 在我的医疗设备健康平台项目中，Redis主要承担了以下几个核心作用：
>
> 首先，它被广泛用于缓存热点数据，例如用户的疗程列表、设备的最新上报数据等，这类数据读多写少、实时性要求高，使用Redis的String或Hash结构可以极大地降低数据库压力。其次，用于分布式锁控制，比如积分扣减、设备状态同步这类并发写操作，我们使用Redisson的可重入锁来防止并发导致的数据异常。第三个常见的场景是用户登录态的会话管理，通过将Token存入Redis并设置过期时间，既能实现高性能认证，又方便做单点登录。最后还有计数器类的场景，例如设备异常次数统计，用incr命令即可实现高并发安全的自增。
>
> 至于数据库与缓存一致性问题，我们采用的是典型的Cache Aside Pattern（旁路缓存模式）配合“延迟双删”策略。
>
> 具体来说，读流程是“先查缓存，缓存未命中再查数据库，查询到结果后回写缓存”；写流程则是“先删缓存，再更新数据库，最后通过延迟机制或消息队列进行二次删除”。这样做的目的在于防止写入MySQL较慢时，读线程从缓存中拿到旧数据。延迟双删的流程是：在更新数据库后，通过RabbitMQ发送一条延时消息（比如0.5到1秒后执行），再次删除对应的缓存键，保证即便在高并发场景下也能最终一致。

在我的医疗设备健康平台项目中，Redis主要用于几个场景：

- 1）作为缓存，存储热点数据如**用户疗程列表、设备最新上报数据**（用String或Hash结构），减少数据库压力；
- 2）分布式锁，比如在积分扣减时用Redisson防止并发问题；
- ~~3）消息队列的补充（如用List实现简单队列），不过我们主要用RabbitMQ；~~
- 4）会话管理，存储用户Token（用String，设置过期时间）；
- 5）计数器，如设备异常报警计数（用Incr命令）。

做缓存时，保证数据库和Redis一致性是关键，我们用的是“延迟双删”策略结合MQ异步更新。

1. **Cache Aside Pattern（旁路缓存模式）**

Cache Aside Pattern是“读先查缓存，缓存未命中查数据库并回写缓存；写操作主动更新或删除缓存”，应用层完全控制缓存的一致性策略。

2. **延迟双删**

### 具体流程：

读时先查Redis，命中返回；未命中查MySQL，查到后写入Redis。

写时（更新/删除数据）：

1. 先删Redis缓存；
2. 更新MySQL；
3. 用RabbitMQ发延迟消息（延时0.5~1秒），再删一次Redis（防止读写并发导致脏数据）。

>  [!tip]
>
> 为什么延迟删？
>
> 因为更新MySQL可能慢，先删缓存避免旧数据被读到，延迟删处理极端情况。

3. **MQ**

>  [!tip]
>
>  ES查不到数据的话就没必要查Mysql了
>
>  ES和Mysql的数据一致性怎么解决 -> 使用MQ
>
>  ES的数据来源于MySQL更新，通过MQ异步监听更新事件，再同步到ES索引中，从而在高并发下保持数据最终一致性。



## 6. Redis有哪些持久化策略

Redis提供了两种主要的持久化策略来防止数据丢失：

**1. RDB（快照持久化）**

- 在指定时间间隔内，将内存中的数据生成快照文件（dump.rdb）。
- **优点**：性能开销小，文件紧凑，适合备份和灾难恢复。
- **缺点**：存在数据丢失风险（快照间的数据可能丢失），fork子进程会消耗资源。

**2. AOF（追加日志持久化）**

- 以日志形式记录所有写命令，每次写操作追加到AOF文件。
- **优点**：数据更完整，可配置同步策略，文件可读方便恢复。
- **缺点**：文件较大，恢复速度比RDB慢，对写性能有一定影响。

RDB适合备份和快速恢复，AOF适合对数据完整性要求高的场景；Redis也支持两者结合使用，兼顾性能与可靠性。



## 7. 说一下哨兵集群的作用是什么？

哨兵（Sentinel）集群是一种高可用性的解决方案，主要的作用有：

1. 监控：持续检查主服务器和从服务器是否正常运行
2. 通知： 当被监控的 Redis 实例发生故障时，Sentinel 可以通过 API 向其他应用程序或管理员发送通知。
3. 自动故障转移：
   - 当主服务器宕机时，Sentinel 之间会进行协商，投票选出一个 Sentinel 来执行故障转移。
   - 选中的 Sentinel 会在众多的从服务器中，通过一系列策略（如优先级、复制偏移量等）选举出一个新的主服务器（`slaveof no one`）。
   - 让其他从服务器去复制新的主服务器（`slaveof <new-master-ip> <new-master-port>`）。
   - 当故障的主服务器重新上线时，它会被自动配置为新主服务器的从服务器。



## 8. 说一下什么是主观下线和客观下线

1. 主观下线（Subjectively Down, SDown）：如果某sentinel节点发现某实例未在规定时间响应,则认为该实例主观下线。
2. 客观下线:若超过指定数量(quorum)的sentinel都认为该实例主观下线,则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。



## 9. 简述全量同步的流程?

- slave节点请求增量同步
- master节点判断replid,发现不一致,拒绝增量同步
- master将完整内存数据生成RDB,发送RDB到slave
- slave清空本地数据,加载master的RDB
- master将RDB期间的命令记录在repl_baklog（环形数组）,并持续将log中的命令发送给slave

repl_baklog是环形数组，接近顺序读写，性能高

注意：repl_baklog大小有上限,写满后会覆盖最早的数据。如果slave断开时间过久,导致尚未备份的数据被覆盖,则无法基于log做增量同步,只能再次全量同步。
