[toc]

---

## 1. 内连接和外连接有什么区别，内连接和外连接的连接条件能放在on和where吗？

内连接(INNER JOIN)：

- 只返回两个表中匹配连接条件的记录

外连接(OUTER JOIN)：

1. 左外连接：返回**左表所有记录** + 右表匹配的记录，右表无匹配项时显示为NULL。
2. 右外连接：返回**右表所有记录** + 左表匹配的记录，左表无匹配项时显示为NULL 。
3. 全外连接：返回两表所有记录，无匹配返回NULL。Mysql不支持。

对于内连接来说，连接条件放在`on`或者`where`结果都是一样的，都是返回匹配的记录

而对于外连接来说，连接条件要写在`on`中，`on`影响连接过程。`where`是写连接完之后的过滤条件，如果在这里写连接条件，可能会将外连接变成内连接。

`ON`中的条件影响连接逻辑
`WHERE`中的条件过滤最终结果，可能改变外连接的语义



## 2. char和varchar的区别

`char`是定长字符串，定义长度是多少就会占用多少，无论实际占用多少（后面是补充空格）存储效率高，但是存在空间浪费。

`varchar`是不定长字符串，只会定义最大长度，但是实际只会占用保存的数据长度。（不会存储多余的空格）



## 3. 说一下事务的隔离级别有哪些？分别解决了什么问题？mysql是什么隔离级别，oracle呢？那不可重复读,脏读,幻读是什么?

事务的隔离级别有四种：读未提交，读已提交，可重复读，串行化

>  读未提交可能出现脏读、不可重复读、幻读
>
>  读已提交可以解决脏读，但是不能解决不可重复读和幻读
>
>  可重复读解决脏读，不可重复读，但是解决不了幻读
>
>  串行化可以解决脏读，不可重复读，幻读

mysql 默认的隔离级别是可重复读，Oracle的默认隔离级别是读已提交

脏读是在并发事务中读到另一个事务未提交的数据

不可重复读是在并发事务中第一次读到的数据和第二次读到的数据不一样

幻读是在并发事务中没有查询到对应数据，但是在插入的时候报已经存在的错误



## 4. 说一下mysql的存储引擎有哪些？说一下InnoDB和MyISAM的区别？

<img src="./assets/image-20251009203116915.png" alt="image-20251009203116915" style="zoom:67%;" />

### mysql的存储引擎

**Mysql 3.x-4.x(1995-2004):**

**MyISAM**：最早的存储引擎，简单高效，但功能有限，不支持事务和外键

**ISAM**(MyISAM的前身，已废弃)

---

**Mysql 5.0(2005-2010):**

**InnoDB**：由Innobase公司开发，支持事务和ACID特性，支持行级锁和外键

**Archive**：专门用于数据归档，高压缩比，只支持INSERT和SELECT

**CSV**：以CSV格式存储数据，方便数据导入导出

**Memory (HEAP)**：数据存储在内存中，访问速度极快

---

**Mysql 5.1(2008-2010):**

**Federated**：远程数据访问

**NDB Cluster**：MySQL集群存储引擎，支持分布式计算

---

之后的都是以InnoDB为主，默认引擎均为InnoDB



### InnoDB和MyISAM的区别

事务处理方面：InnoDB支持ACID事务（引出ACID事务是什么？原子性、一致性、隔离性、持久性），MyISAM不支持事务。

行锁和表锁方面：InnoDB支持行级锁定和表级锁定，MyISAM只支持表级锁定。

外键约束方面（维护关联表的数据一致性）：InnoDB支持，MyISAM不支持。

崩溃恢复能力：InnoDB 支持崩溃恢复（redo Log），MyISAM 不支持。

全文索引方面：MyISAM的性能通常比InnoDB好（8.0后性能已经赶上甚至超过了，原因是上面那些区别）。

<img src="./assets/image-20251009203330902.png" alt="image-20251009203330902" />



## 5. 说一下数据库的三范式和反三范式

// TODO 差总结，精炼版

> [!tip]
>
> - **写操作（插入、更新、删除）多的表**，倾向于使用**三范式**来保证数据一致性和完整性。
> - **读操作（查询）频繁，且对性能要求极高的表或场景**，可以有选择性地使用**反三范式**来优化。

### 数据库三范式（3NF）

首先，我们来说说**三范式（3NF）**，也叫**数据库规范化（Normalization）**。

三范式的核心思想是**减少数据冗余，保证数据的一致性和完整性**。它就像是一种“数据瘦身”的方法，把数据分解到不同的表中，每张表只存储特定类型的信息。

三范式包括三个主要的规则：

**1. 第一范式（1NF）：原子性**

- 要求数据库表的每一列（字段）都是不可再分的最小数据单元。
- 简单来说，一个字段里不能再包含多个值。比如，一个`地址`字段不能同时存储`省`、`市`和`区`，而是应该拆分成独立的`省`、`市`、`区`字段。

**2. 第二范式（2NF）：消除部分依赖**

- 要求数据库表中的**非主键列**必须完全依赖于**主键**。

- 如果一个表的主键是联合主键（由多个字段组成），那么表中任何非主键字段都不能只依赖于主键的一部分。

  

**3. 第三范式（3NF）：消除传递依赖**

- 要求在2NF的基础上，**非主键列**之间不能有**传递依赖**。
- 简单来说，非主键列不能依赖于另一个非主键列。

优点：

- **减少数据冗余**：节省存储空间。
- **数据一致性高**：修改一处即可，避免了多处修改导致的数据不一致问题。
- **更新、插入和删除异常少**：更容易维护。

**三范式的缺点**：

- **查询效率低**：因为数据分散在多个表中，查询时需要进行多次**联接（JOIN）**操作，这会增加查询的开销。
- **模型过于复杂**：表太多，可能难以理解和维护。

------



### 反三范式（De-normalization）

既然三范式有缺点，那么**反三范式**就是为了解决这些问题而出现的。

**反三范式**的核心思想是**牺牲部分数据冗余，以换取查询性能的提升**。它不是完全不遵守范式，而是在遵循范式设计的基础上，为了特定的性能需求，故意引入一些冗余数据。

**常用的反三范式策略**：

- **增加冗余字段**：在A表里存储B表的数据，从而在查询时可以避免JOIN操作。
- **创建汇总表**：预先计算好一些聚合数据（如订单总额、用户总数等），并存放在单独的表中，以加快报表和统计查询。

**反三范式例子**：

- 为了加快`订单列表`的展示，我们可以在`订单表`中冗余存储`商品名称`、`客户姓名`等信息。
  - **三范式设计**：查询订单列表需要JOIN`商品表`和`客户表`。
  - **反三范式设计**：直接从`订单表`中查询，无需联接。

**反三范式的优点**：

- **查询性能高**：减少了多表联接，大大提高了查询速度。
- **简化查询逻辑**：一些复杂的查询变得更简单。

**反三范式的缺点**：

- **数据冗余**：增加了存储空间。
- **数据一致性风险**：当冗余数据源头发生变化时，需要额外机制来保证冗余数据同步更新，否则容易出现数据不一致。
- **更新、插入、删除操作开销增大**：需要同时修改多处数据。





## 6. sql的书写顺序是什么？执行顺序又是什么？

以查询语句为例：

书写顺序：

select -> distinct -> from -> join -> on -> where -> group by -> having -> order by -> limit

执行顺序：

from -> join -> on -> where -> group by -> having -> select  -> distinct -> order by -> limit



## 7. 说一下mysql的主从复制原理？

MySQL主从复制是一种将一个MySQL数据库实例（主库）的数据变更，同步到另一个或多个数据库实例（从库）的技术。其核心原理是基于MySQL的**二进制日志（binlog）**。

复制过程主要有三个线程：

- **主库I/O线程（Binlog Dump Thread）**：当从库连接上来时，主库会创建一个I/O线程，将**binlog event**（数据变更事件）发送给从库。
- **从库I/O线程（Replica I/O Thread）**：从库连接到主库后，会创建该线程。它负责接收主库I/O线程发过来的binlog event，并将这些事件写入到从库本地的**Relay Log（中继日志）**中。
- **从库SQL线程（Replica SQL Thread）**：该线程负责读取**Relay Log**中的事件，并逐一在从库上执行，从而实现数据的同步。

**基本流程：**

1. **开启binlog**：主库必须开启binlog功能，记录所有的数据修改操作。
2. **从库连接**：从库配置好主库的地址、端口、用户名密码等信息后，连接到主库。
3. **主库发送binlog**：主库I/O线程开始将binlog内容发送给从库。
4. **从库接收和写入**：从库I/O线程接收binlog并写入到本地的Relay Log中。
5. **从库执行**：从库SQL线程读取Relay Log，并在从库上执行相同的SQL语句。



Mysql读写分离，读不到怎么解决？

- Mybatis手动指定读的数据库
- Mysql高版本支持配置sql多线程加快relay log落库

为什么低版本不支持？



## 8. 说一下mysql有哪些日志文件？

MySQL有多种重要的日志文件，它们用于不同的目的：

- **错误日志（Error Log）**：记录MySQL服务器的启动、关闭、运行中的错误、警告信息。这是诊断MySQL故障的首要文件。
- **二进制日志（Binary Log / Binlog）**：记录所有对数据库的**数据变更**操作，如`INSERT`、`UPDATE`、`DELETE`、`DDL`等。它不记录`SELECT`等查询操作。Binlog是MySQL主从复制和数据恢复（基于时间点的恢复）的基础。
- **查询日志（General Query Log）**：记录所有**接收到的SQL语句**，包括查询、写入、连接等。开启该日志会产生大量数据，通常只用于调试。
- **慢查询日志（Slow Query Log）**：记录执行时间超过指定阈值的SQL语句。它是数据库性能优化的重要工具。
- **重做日志（Redo Log）**：是InnoDB存储引擎特有的日志。它记录了**事务的物理变更**，用于保证事务的持久性（Durability）。即使系统崩溃，也可以通过Redo Log恢复到崩溃前的状态。
- **回滚日志（Undo Log）**：也是InnoDB特有。它记录了数据修改前的状态，用于事务回滚和MVCC（多版本并发控制）。



## 9. 说一下mysql索引的底层数据结构？为什么选择b+树，而不是hash、二叉树、平衡二叉树、红黑树、b树？





## 10. b树和b+树的区别?





## 11. hashmap为什么不选择b+树?





## 12. 聚集索引[聚簇索引]和非聚集索引[非聚簇索引]的区别?





## 13. 介绍一下常见的索引类型?





## 14. 三层的b+树大概可以存储多少数据?





## 15. 深分页查询如何优化





## 16. 什么是回表?怎么优化回表





## 17. 什么是覆盖索引





## 18. 什么情况会导致索引失效





## 19. 什么是最左匹配原则?





## 20. a、b、c按照顺序建立联合索引,下列情况会不会走索引:





## 21. 建立索引一般要考虑什么?





## 22. 有没有做过sql调优?





## 23. 有没有做过数据库调优





## 24. 如何定位慢查询

