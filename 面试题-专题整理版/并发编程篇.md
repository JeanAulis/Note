[toc]

---

# 并发编程

## 1. 什么是aqs？aqs有哪些常用的实现？公平锁和非公平锁的区别

aps：**A**bstract**Q**ueued**S**ynchronizer，抽象队列同步器，是JUC包中用于实现锁和同步器的核心机制，~~核心设计思想是**模版方法模式**~~。它基于FIFO（先进先出）队列和 CAS（Compare-And-Swap）操作，提供阻塞式锁和相关同步器的框架。

AQS的常用实现有：
ReentrantLock：可重入锁，支持公平锁和非公平锁。
ReentrantReadWriteLock：读写互斥锁，读读共享，读写互斥，写写互斥
Semaphore：信号量，用来控制同时访问某个资源的线程数。
CountDownLatch：倒计时器，用来控制一个或多个线程等待其他线程完成某个操作。

公平锁和非公平锁的区别：
从顺序性来说：公平锁严格遵守FIFO队列顺序，而非公平锁允许插队；
从性能方面来说：非公平锁通常性能优于公平锁，因为它减少了线程切换开销；
适用场景：非公平锁适合高吞吐量的场景，公平锁适合需要严格遵守执行顺序的场景。

<img src="./assets/image-20251009204046744.png" alt="image-20251009204046744" />



## 2. 有了解过volatile关键字吗？他的作用是什么？

我有了解。volatile是Java中的一个关键字，是一个轻量的同步机制，能保证变量的可见性和有序性，但是不能保证原子性。

首先，保证可见性就是线程修改了变量的值，修改后的值马上会被其他线程看到；保证了有序性就是防止指令重排，避免重排后导致的逻辑错误。

<img src="./assets/image-20251009204842669.png" alt="image-20251009204842669" />



## 3. 线程和进程的区别?说一下线程有哪些状态?说一下java线程有哪些状态？怎么杀死一个线程？

进程：是操作系统分配资源的基本单位
线程：是进程内的执行单元
**主要区别**：

1. **资源分配**：进程独占资源，线程共享进程资源。
2. **独立性**：进程间独立，线程间可能相互影响（共享内存）。
3. **开销**：进程创建/切换成本高于线程。
4. **通信**：进程间通信（IPC）复杂，线程间通过共享内存通信更简单。

线程状态：

- New:新建
- Runnable:可运行
- Running:运行
- Blocked:阻塞
- Terminated:终止

Java线程状态：

- NEW:线程创建但未启动
- RUNNABLE:可运行状态(包括正在运行和等待CPU调度)
- BLOCKED:等待获取锁
- WAITING:无限等待(如wait())、join()
- TIMED_WAITING:定时等待(如sleep()、wait(timeout))
- TERMINATED:线程结束

中断线程更优雅的方法:interrupt()，interrupt()是设置中断标志，不是直接停止线程，它发送一个中断信号，让线程自己决定什么时候来中断，强制删除：kill -9

<img src="./assets/image-20251009210607220.png" alt="image-20251009210607220" style="zoom:120%;" />



## 4. 实现多线程有哪些方式？什么是守护和非守护线程？

**实现多线程的方式**：

1. 继承 `Thread` 类，重写 `run` 方法。
2. 实现 `Runnable` 接口，传入 `Thread` 构造器。
3. 实现 `Callable` 接口，使用 `FutureTask` 或线程池获取返回值。
4. 使用线程池（如 `ExecutorService`）管理线程。

**守护线程与非守护线程**：

- **守护线程**：后台运行，JVM退出时自动终止（如垃圾回收线程）。通过 `setDaemon(true)` 设置，需在启动前设置。
- **非守护线程**：前台线程，JVM需等待其执行完成才会退出（如主线程）。默认创建为非守护线程。



## 5. sleep和wait的区别？notify和notifyall的区别？

sleep属于Tread类，作用是让当前线程暂停执行一段时间，进入阻塞状态，但是不释放锁，而wait属于Obeject

// TODO

<img src="./assets/image-20250905123621932.png" alt="image-20250905123621932" style="zoom:67%;" />

<img src="./assets/image-20251009212115492.png" alt="image-20251009212115492" />



## 6. 你知道本地线程变量吗？你在项目中用它来做什么？使用上一般要注意什么？

本地线程变量也就是ThreadLocal，它是Java提供的一个线程隔离机制，通过无锁操作让每个线程都拥有自己独立的变量副本。

> ThreadLocal的好处是保证了线程安全，因为每个请求都是在独立的线程中处理的，所以不会出现多个用户之间数据混乱的问题。

在我们项目中，主要在用户身份认证这块使用了ThreadLocal。具体场景是这样的：当非登录请求的请求头携带token进来的时候，拦截器获取并解析JWT token，校验合法之后就把用户的信息存储到ThreadLocal中。这样在整个请求处理过程中，不管是Controller层、Service层还是Dao层，都可以通过ThreadLocal来获取当前登录用户的信息，而不需要在每个方法参数中都传递用户对象。

> 我们封装了一个UserContext工具类来管理ThreadLocal：
> 比如setCurrentUser()方法用来存储用户信息，getCurrentUser()方法用来获取当前用户，还有removeCurrentUser()方法用来清理数据。

> [!important] 
>
> 但是使用ThreadLocal也要注意内存泄漏的问题，所以我们在请求处理完成后，会在拦截器的afterCompletion方法中调用`ThreadLocal.remove()`来及时清理数据，避免线程池复用线程导致内存泄漏。
>
> ### 为什么不在postHandle方法使用ThreadLocal.remove()？
>
> postHandle只有在Controller方法正常执行完成后才会被调用，如果Controller层抛出异常，postHandle就不会执行，这样ThreadLocal中的数据就无法被清理，造成内存泄漏。而afterCompletion无论是否发生异常都会被调用，更加可靠。

<img src="./assets/image-20251010092246383.png" alt="image-20251010092246383" />



## 7. 什么是线程安全？怎么解决线程安全问题？

线程安全是指在多线程环境下，多个线程同时访问共享资源时，程序能够正确执行并且保证数据的一致性，不会出现数据混乱或者不可预期的结果。 简单来说，就是当多线程同时操作同一个数据时，不会互相影响导致数据错误。

**为什么出现非线程安全的问题？**主要有三个原因：第一是原子性问题，比如i++操作被中途打断；第二是可见性问题，一个线程修改了变量但其他线程看不到；第三是有序性问题，编译器指令重排序导致执行顺序与预期不符。

解决方法：

在设计的时候，避免资源共享，使用无状态的类，不使用成员变量，数据都存储在局部变量中；使用ThreadLocal实现线程隔离，每个线程都有自己的变量副本。

如果无法避免共享，就进行同步控制：使用线程安全的工具类，比如ConcurrentHashMap、AtomicInteger；使用synchronized或者ReentrantLock；使用volatile关键字保证变量的可见性和禁止指令重排（不能保证原子性）；还有乐观锁和悲观锁。



> [!tip] 
>
> 总结如下
>
> - 使用ThreadLocal实现线程隔离；
> - 使用乐观锁或悲观锁；
> - 使用线程安全的集合类（如ConcurrentHashMap）
> - 使用volatile关键字保证变量可见性
> - 使用不可变对象
> - 使用原子类或原子操作保证操作的原子性；（AtomicInteger、AtomicLong）
> - ~~使用synchronized或ReentrantLock实现同步控制~~；
> - ~~还有通过分布式锁来解决分布式环境下的并发问题~~。



# 线程池

## 1. 线程池的作用是什么？

1. **降低资源消耗**：线程池里的线程是可以重复利用的。一旦线程完成了某个任务，它不会立即销毁，而是回到池子里等待下一个任务。这就避免了频繁创建和销毁线程带来的开销。
2. **提高响应速度**：因为线程池里通常会维护一定数量的核心线程，任务来了之后，可以直接交给这些已经存在的、空闲的线程去执行，省去了创建线程的时间，任务能够更快地得到处理。
3. **提高线程的可管理性**：线程池提供了一套统一的机制来管理、监控和控制并发线程的数量。这有助于**防止因线程数量过多而导致的资源耗尽**，从而保证系统的稳定性和高可用性。

>  [!CAUTION]
>
> 《阿里巴巴 Java 开发手册》强制线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险



## 2. 说一下线程池的工作原理？

> “先核心线程，再任务队列，最后临时线程”

1. **判断核心线程数：**
   - 线程池首先检查当前正在运行的线程数是否**小于** `corePoolSize`（核心线程数）。
   - **如果小于**，则立即创建一个新的**核心线程**来执行这个任务。
2. **尝试放入任务队列：**
   - **如果当前运行的线程数**已经达到或超过 `corePoolSize`，则不会立即创建新线程，而是尝试将任务放入 `workQueue`（任务队列）中。
   - **如果成功入队**，任务就在队列中等待，由空闲的核心线程来执行。
3. **创建临时线程（非核心线程）：**
   - **如果任务队列已满**，线程池会继续检查当前运行的线程数是否**小于** `maximumPoolSize`（最大线程数）。
   - **如果小于**，则创建一个新的**临时线程**来执行这个任务。
4. **执行拒绝策略：**
   - **如果当前线程数**已经达到 `maximumPoolSize`，并且任务队列也已满，线程池将无法处理新任务。
   - 此时，线程池会根据配置的 `handler`（拒绝策略）来决定如何处理，例如：抛出异常、直接丢弃任务、或让提交任务的线程自己来执行。

> 核心线程 -> 任务队列 -> 临时线程 -> 拒绝策略

<img src="./assets/image-20251009212718284.png" alt="image-20251009212718284" />



## 3. 线程池有哪些核心参数？

七大核心参数：

- `corePoolSize` : 这是线程池中**常驻的核心工作线程数量**。即使这些线程处于空闲状态，它们也不会被销毁（除非设置了 `allowCoreThreadTimeOut`）。当任务提交时，如果当前运行的线程数小于该值，线程池会优先创建新的核心线程来执行任务。
- `maximumPoolSize` : 这是线程池中**允许存在的最大线程数量**。当任务队列已满，并且当前运行的线程数小于此值时，线程池会创建新的**非核心线程（临时线程）**来处理任务。
- `workQueue`: 一个用于**存放待执行任务的阻塞队列**。当线程池中的线程数达到 `corePoolSize` 后，新提交的任务会被放入这个队列中排队等待执行。
- `keepAliveTime`:当线程池中的线程数量**超过 `corePoolSize`** 时，这些**非核心线程**在空闲等待新任务的`最长存活时间`。如果超过这个时间仍然没有新任务，该线程就会被销毁。
- `unit` : 这是一个枚举类型，定义了 `keepAliveTime` 参数的时间单位，如秒、毫秒等。
- `threadFactory` :executor 创建新线程的时候会用到。用于**创建新线程的工厂类**。我们可以通过它来自定义线程的创建，比如给线程指定有意义的名称、设置优先级等，方便后续排查问题。
- `handler` :拒绝策略。当线程池和任务队列都已满，无法再处理新任务时，线程池会**根据此策略来处理被拒绝的任务**，例如抛出异常或丢弃任务。

## 4. 线程池的拒绝策略有哪些？

**`ThreadPoolExecutor` 拒绝策略定义:**

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，`ThreadPoolExecutor` 定义一些策略:

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。



## 5. 常用有哪些阻塞队列和怎么选择？

新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。

- `ArrayBlockingQueue`
  - **有界队列**：创建时必须指定固定容量。**这是它最核心的特点，用于防止任务无限堆积导致内存溢出（OOM）**。
  - **数组实现**：内部由数组存储，内存连续。
  - **一把锁**：生产（入队）和消费（出队）共用同一把锁，在高并发场景下吞吐量相对较低。

- 容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：`FixedThreadPool` 和 `SingleThreadExector` 。`FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。



>  [!tip]
>
> 其他阻塞队列
>
> - `SynchronousQueue`（同步队列）：`CachedThreadPool` 。`SynchronousQueue` 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。
> - `DelayedWorkQueue`（延迟阻塞队列）：`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor` 。`DelayedWorkQueue` 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。`DelayedWorkQueue` 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。



## 6. 你在项目中怎么设置线程池的线程数？

- **计算密集型任务：** 这种任务大部分时间都在进行 CPU 运算，很少涉及 I/O 操作。如果线程数过多，会导致频繁的上下文切换，反而降低效率。通常建议将线程数设置为 **CPU 核心数 + 1**（或者 CPU 核心数）。例如，`Runtime.getRuntime().availableProcessors()`。
- **I/O 密集型任务：** 这种任务大部分时间都在等待 I/O 操作（如数据库查询、文件读写、网络请求等），CPU 占用率不高。为了充分利用 CPU 在等待 I/O 时的空闲时间，可以创建更多的线程。一个常用的经验公式是 **CPU 核心数 \* (1 + 线程等待时间 / 线程 CPU 时间)**。一个更简单的估算是 **CPU 核心数 \* 2**。



## 7. 常用的线程池有哪些种类？

### FixedThreadPool：

核心线程数和最大线程数相等，线程数是固定的。它使用无界队列，任务数再多也不会创建超过核心线程数的线程。

### SingleThreadExecutor

只有一个线程的线程池。它确保所有任务都在单个线程中按顺序执行。可以看作是线程数为 1 的 `FixedThreadPool`。

### CachedThreadPool

核心线程数为 0，最大线程数为 `Integer.MAX_VALUE`。它使用同步队列，当有任务时会立即创建新线程（如果有空闲线程则复用），线程数会动态增长，空闲线程在 `keepAliveTime` 后会被销毁。

### ScheduledThreadPool

用于执行定时和周期性任务，它使用 `DelayedWorkQueue`，可以延迟或定时执行任务。



# 事务

## 1. 什么是事务？你说一下事务有哪些特性？

事务是数据库操作的一个逻辑单元，是一组操作的集合，要么全部操作成功，要么全部操作失败，从而保证数据的正确性和完整性。



事务的四大特性（ACID）有：原子性、一致性、隔离性、持久性

1). 原子性指的是事务中的这一组操作，是不可分割的最小操作单元了，操作要么全部成功，要么全部失败。

2). 一致性是指在事务操作的前后，必须使数据处于一致的状态。

3). 隔离性指的是数据库中提供了隔离机制，保证事务在不受外部并发操作的影响的独立环境中运行。

4). 持久性就比较简单了，就是事务一旦提交或回滚了，它对数据库的改变就是永久的



## 2. 事务的传播行为有哪些？`REQUIRES_NEW`一般用在什么场景？

------

事务的传播行为（**Propagation Behavior**）定义了当一个方法在一个已有的事务中被调用时，它应该如何参与或创建事务。Spring框架中常用的事务传播行为包括：

- **`REQUIRED`**：这是默认行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **`SUPPORTS`**：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
- **`MANDATORY`**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
- **`NEVER`**：以非事务方式执行，如果当前存在事务，则抛出异常。
- **`NOT_SUPPORTED`**：以非事务方式执行，如果当前存在事务，则将其挂起（**suspend**）。
- **`REQUIRES_NEW`**：**创建一个新的事务**，并且**挂起**当前已有的事务。
- **`NESTED`**：如果当前存在事务，则创建一个**嵌套（nested）事务**，这个嵌套事务是外部事务的一部分。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务可以独立于外部事务进行部分回滚。如果当前没有事务，则创建一个新事务，行为类似于 `REQUIRED`。

**`REQUIRES_NEW`** 的常用场景是：

- **日志记录或监控**：在主业务逻辑失败时，你仍然需要确保记录日志的操作能够成功提交，不被主事务的回滚所影响。
- **独立子操作**：某个操作（如发送邮件、短信通知）即使主业务失败也必须成功，或者需要独立于主业务进行提交或回滚。
- **解耦**：当需要确保某个子操作的原子性，且不希望它的失败影响到外部主事务，或者它的成功不依赖于主事务的提交。



## 3. 首先说一下导致事务失效有哪些场景？

------

> [!note]
>
> 在刚开始上班做项目时，遇到过，但是现在在做项目，写代码时，都会规避这些坑。 事务失效比较典型的场景呢就是：
>
> - 第一个，如果业务方法上try、catch处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了抛出去就行。
> - 第二个，如果方法抛出检查异常，如果报错也会导致事务失效，因为默认spring事务管理只会针对于RuntimeException进行回滚。那这个呢，就可以在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception.class，这样别管是什么异常，都会回滚事务。
> - 第三个，是我早期开发中遇到的一个，如果业务方法上不是public修饰的，也会导致事务失效。
>
> 嗯，就能想起来那么多

事务失效（**Transaction Ineffectiveness**）通常是由于开发者在使用 Spring 事务注解 `@Transactional` 时，没有遵循其内部工作原理而导致的。常见场景包括：

- **非`public`方法**：`@Transactional` 注解只对 **`public`** 方法生效。这是因为 Spring AOP（面向切面编程）的动态代理机制是基于接口或类的，只有 `public` 方法才会被代理拦截。如果你的方法是 `protected`、`private` 或默认（包私有）访问修饰符，事务将不会生效。
- **在同一个类中调用**：当一个被 `@Transactional` 注解的方法被其**同一个类内部**的另一个方法调用时，事务会失效。这是因为`a.b()`这种**内部调用**本质上是`this.b()`，它会绕过 Spring AOP 的代理对象，直接调用原始对象的方法，因此事务代理不会起作用。
- **捕获了异常但没有抛出**：如果 `@Transactional` 方法内部抛出了异常，但是你使用 `try...catch` 块捕获了它，并且没有重新抛出（`throw`），Spring 就不会感知到这个异常，因此事务无法回滚。默认情况下，Spring 只对**运行时异常**（`RuntimeException`）和 **`Error`** 进行回滚。
- **错误的`rollbackFor`配置**：如果你需要对**检查型异常**（**Checked Exception**，如`IOException`、`SQLException`）进行回滚，但没有在 `@Transactional` 中显式配置 `rollbackFor = Exception.class`，那么事务在遇到这类异常时也不会回滚。
- **数据库引擎不支持事务**：例如，MySQL 的 `MyISAM` 存储引擎不支持事务，只有 `InnoDB` 引擎才支持。



## 4. 你在项目中有使用过多线程吗？（提示：面试必问，一定要结合的我们准备的实际项目中找一个业务场景来迁移使用线程池，而且还要合理的）

// TODO

有的面试官，我之前做过一个物联网平台的项目，

IoT实时接收设备数据的时候，使用了线程池来解决大量消息堆积的问题，加快数据落库

>  [!tip]
>
> 有，在我们商城日均订单量在8-10w单，大约3%-5%用户超时未支付，每天要处理 2400-5000 个超时订单，我们每天都要处理这些超时的订单，在这里用到了线程池的技术，定时任务分页查询每页取 100 条订单，单线程处理时，5000 个订单需要约 50分钟（平均每个订单处理耗时约 0.84 秒）用线程池并发处理后，同样 5000 个订单只需要10-15分钟，效率提升了 3-4 倍
> 具体实现时，线程池参数是这样配置的：
> 核心线程数设为 8（服务器是 4 核 CPU，按 CPU 核心数的 2 倍配置）
> 最大线程数 16（核心线程数的 2 倍，应对峰值）
> 任务队列容量 2000（经过压测，这个容量能缓冲大促期间的订单峰值）
> 空闲线程存活时间 60 秒（避免频繁创建销毁线程）

>  [!important]
>
> 可能会问：
>
> 详见 [09-15.md](09-15.md) 
>
> 1. 线程池的作用
> 1. 线程池的工作原理
> 1. 线程池的七大核心参数
> 1. 线程池的核心参数
> 1. 线程池常用的种类



## 5. 说一下cap定理和base理论？

### CAP定理

CAP定理是分布式系统设计的基础，由Eric Brewer提出，指Consistency（一致性）、Availability（可用性）、Partition tolerance（分区容错性）三者不可兼得，只能取其二。在网络分区（P）不可避免时，要在C和A间权衡。

- **C(Consistency, 一致性)**：所有节点同一时刻数据一致，如银行转账必须强一致。
- **A(Availability, 可用性)**：每个请求都能收到响应，即使是失败响应（系统始终可用）。
- **P(Partition tolerance, 分区容错性)**：系统在网络分区（节点间通信故障）时仍能继续运行（分布式系统必须满足）。

例如，MySQL主从复制偏CP（主库写，从库读，但分区时可能不一致）；Redis集群偏AP（异步复制，分区时可用但不强一致）。

- CP系统（如HBase）：牺牲A，确保C和P，适合金融场景。
- AP系统（如Cassandra）：牺牲C，确保A和P，适合社交网络。
- CA系统（如传统单机数据库）：牺牲P，但分布式环境下P不可避。

证明依据：网络分区不可避免（P必须），若分区发生，需选择放弃C（允许临时不一致）或A（部分节点 downtime）。

### BASE理论

BASE理论是eBay的Dan Pritchett基于CAP的实际应用，是Basically Available（基本可用）、Soft state（软状态）、Eventually consistent（最终一致性）的缩写。强调在分布式系统中牺牲强一致，转而追求高可用和最终一致，适合电商、社交等场景。

**BA（Basically Available，基本可用）**：系统整体可用，但允许部分失效（如响应降级）。

**S（Soft State，软状态）**：数据状态可临时不一致，需通过异步更新维护。

**E（Eventual Consistency，最终一致性）**：数据最终会一致，但不保证实时（例如DNS系统）。

与ACID（原子性、一致性、隔离性、持久性）对比：BASE牺牲强一致性换取可用性，适合大数据、高并发场景如电商推荐系统。

项目中，我们的微服务用Nacos（AP模型），订单服务追求最终一致（用MQ异步），而用户登录用Redis锁追求强一致（CP）。



## 6. 你项目中哪里用到了分布式事务？你们这个场景为什么选择at模式不选择其他模式？说一下seata的at模式原理？

在项目中，分布式事务主要用在订单支付场景：~~用户支付后，需要扣减积分（会员服务）、更新订单状态（订单服务）、发短信通知（消息服务）~~，这些跨微服务，用Seata保证一致性。（调用了其他的微服务openFeign）

> [!Caution] 
>
> // TODO
>
> 再具体一些，不然经不住拷打

为什么选择AT模式：AT（Automatic Transaction）是Seata的默认模式，适合我们这种**对一致性要求不高但开发简单**的场景（最终一致够用）。

> [!Caution] 
>
> // TODO
>
> 选一个具体的场景

**为什么不选择其他的模式？**

不像TCC（Try-Confirm-Cancel）需要手动写补偿逻辑，侵入性强；SAGA适合长事务，但我们的事务链短；XA太重，性能差。我们订单不是金融级强一致，AT的自动回滚和低侵入性正好（只需加@GlobalTransactional注解）。

Seata AT模式原理：基于两阶段提交（2PC）。事务管理器（TM）启动全局事务，并向事务协调器（TC）注册。第一阶段（Prepare）：TC通知资源管理器（RM）执行本地事务，RM用Undo Log记录回滚镜像（before/after image），但不提交；第二阶段（Commit/Rollback）：TM根据业务逻辑决定提交或回滚，如果所有RM成功，TM通知TC Commit；任意失败，TM通知TC Rollback，TC通知RM用Undo Log自动回滚。~~分支事务用Branch Table记录，全局用Global Table管理。Seata Server（TC）用DB/Redis/File存储事务状态。~~

<img src="./assets/image-20251010212106762.png" alt="image-20251010212106762" />

> [!note]
>
> ### AT模式（Automatic Transaction）
>
> 
>
> ### TCC模式（Try-Confirm-Cancel）
> 
> 
>
> ### Saga模式
> 
> 
> 
> ### XA模式
> 
> 



## 7. 数据库分库分表的原因？ 

> [!tip]
>
> 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表

分库分表的目的在于减少数据库单库单表的负担，提高查询性能，缩短查询时间。 分库分表分别水平切分和垂直切分。 垂直切分：分为垂直分库和垂直分表，其中垂直分库是指根据业务的耦合度，将关联度较低的不同表存储于不同的库中，类似于大系统拆分为小系统；垂直分表是指基于数据库表中的列，将不常用的列进行划分成新表，可以使单个表中的数据量变少减少跨页，使得单个页中字段更多，使内存能够加载更多的数据，提高命中率，减少磁盘IO，提高性能。 水平切分：水平切分是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。但只是库内分表，仅仅是解决了单表数据过大的问题，并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。 使用哪种方式分库分表需要依据情况而定，比如数据库是因为表太多而造成海量数据，并且项目的各项业务逻辑划分清晰、低耦合，那么规则简单明了、容易实施的垂直切分必是首选。而如果数据库中的表并不多，但单表的数据量很大、或数据热度很高，这种情况之下就应该选择水平切分，水平切分比垂直切分要复杂一些，它将原本逻辑上属于一体的数据进行了物理分割，除了在分割时要对分割的粒度做好评估，考虑数据平均和负载平均，后期也将对项目人员及应用程序产生额外的数据管理负担。 



不重要的“成本表”比如日志表：

![image-20251011095038924](./assets/image-20251011095038924.png)