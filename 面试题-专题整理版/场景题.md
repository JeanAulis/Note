[toc]

---

## 1. 场景题：有一个类，当中有ab两个方法：第一种情况：a加了@Transactional，b加了@Transactional(propagation = Propagation.REQUIRES_NEW)，然后a方法内部会调用b方法，这时候外部调用a方法，这时候b方法抛出异常，a方法会回滚吗？反过来a方法抛出异常，b方法会回滚吗？为什么？

第二种情况：基本情况同上，a没有加@Transactional，b加了@Transactional，这时候外部调用a方法，b方法抛出了异常的话，b方法会回滚吗？

[事务的传播行为](./并发编程篇.md)

第一种情况：a加了@Transactional，b加了@Transactional(propagation = Propagation.REQUIRES_NEW)，然后a方法内部会调用b方法，这时候外部调用a方法，这时候b方法抛出异常，a方法会回滚吗？反过来a方法抛出异常，b方法会回滚吗？为什么？

第二种情况：基本情况同上，a没有加@Transactional，b加了@Transactional，这时候外部调用a方法，b方法抛出了异常的话，b方法会回滚吗？



**第一种情况：`a`加了`@Transactional`，`b`加了`@Transactional(propagation = Propagation.REQUIRES_NEW)`，`a`调用`b`，外部调用`a`**

- **`b`方法抛出异常，`a`方法会回滚吗？**
  - **会**。
  - **原因**：当外部调用 `a` 方法时，`a` 方法开启一个事务T1。当 `a` 调用 `b` 时，由于 `b` 的传播行为是 `REQUIRES_NEW`，Spring 会**挂起**T1，并为 `b` 创建一个新的事务T2。如果 `b` 抛出异常，T2会回滚，异常会向上传播。当异常被 `a` 方法捕获，`a` 所在的T1事务也会被标记为回滚（rollback-only），因为外部异常的传播，T1最终也会回滚。
- **反过来`a`方法抛出异常，`b`方法会回滚吗？**
  - **会**。
  - **原因**：`b`是在和`a`同一个类被`a`调用，所以并不会被AOP拦截，`b`事务并不会生效，故`b`不会被回退

**第二种情况：`a`没有加`@Transactional`，`b`加了`@Transactional`，`a`调用`b`，外部调用`a`**

- **`b`方法抛出了异常的话，`b`方法会回滚吗？**
  - **不会**。
  - **原因**：`b`是在和`a`同一个类被`a`调用，所以并不会被AOP拦截，`b`事务并不会生效，故`b`不会被回退
