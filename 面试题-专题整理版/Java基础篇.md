[toc]

---

## 1. Final有什么用

- 对于类来说，被final修饰的类不可以被继承
- 对于方法来说，被final修饰的类不可以被重写
- 对于变量来说，被final修饰的变量不可以被改变
- final修饰不可变的是变量的引用，而不是引用指向的内容，**引用指向的内容可以改变**



## 2. 什么是重载（Overload）和重写（Override） ?

- **重载**呢是发生在同一个类里面，**方法的参数列表必须不同**，也就是参数类型和个数还有顺序至少有一个不同，重载是通过方法参数来区分的，而不是通过返回类型。
- **重写**则发生在父子类中，方法名，参数列表必须相同。返回值、抛出的异常，小于等于父类，访问修饰符private<default<protect<public必须大于等于父类，当父类为private则不能重写



## 3. 重载的方法能否根据返回类型进行区分？

方法重载不可以根据返回类型区分



## 4. ==和equals的区别？equals相等hashcode一定相等吗？hashcode相等equals一定相等吗？什么场景需要重写equals和hashcode方法？具体怎么重写equals和hashcode方法？

- == 是判断两个对象的地址是不是相等，就是判断两个对象是不是同一个对象。对于基本数据类型：==比较的是值，应用数据类型 ： == 比较的是内存地址。
- equals()：和==相同，比较的是内存地址，但是equals()可以被重写，对于字符串和包装类，使用equals()可以避免缓存陷阱

一定。

也不一定



## 5. String和StringBuffer、StringBuilder的区别是什么？

- String具有不可变性：String类中使用字符串数组保存字符串，所以String对象是不可变的，StringBuilder与StringBuffer这两种对象是可变的（底层实现的是动态扩容的char[]）
- 线程安全：String因为其不可变，天然线程安全。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。
- 性能：每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。StringBuilder相比使用StringBuffer而言效率更高。



## 6. java中基本类型有哪些？

| 基本类型  | 包装类      | 示例                   |
| :-------- | :---------- | :--------------------- |
| `byte`    | `Byte`      | `Byte b = 100;`        |
| `short`   | `Short`     | `Short s = 500;`       |
| `int`     | `Integer`   | `Integer i = 1000;`    |
| `long`    | `Long`      | `Long l = 10000L;`     |
| `float`   | `Float`     | `Float f = 3.14f;`     |
| `double`  | `Double`    | `Double d = 3.14;`     |
| `char`    | `Character` | `Character c = 'A';`   |
| `boolean` | `Boolean`   | `Boolean flag = true;` |



## 7. 什么是反射？

反射就是允许程序在运行过程中动态地获取类的信息（成员变量、方法、构造器等）。

>  **反射**（Reflection）是 Java 提供的一种机制，允许程序在运行时动态地获取类的信息、创建对象、调用方法、访问字段等。反射使得 Java 程序能够在运行时获取类、方法、字段等元数据并进行操作，从而实现更灵活和动态的功能。

>  [!tip]
>
> 获取class的方法



## 8. (待整理)反射机制优缺点

优点： 运行期类型的判断，动态加载类，提高代码灵活度。

缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要 慢很多



## 9. (待整理)在你进行项目开发的过程中有没有用到过反射 

在我们的项目中经常会使用反射 + 自定义注解的方式去实现一些功能 , 例如 : 

1. 在前后端交互的时候, 后端Long类型返回前端后会产生精度丢失 , 我们的处理方式就是在服务端, 通过配置修改Jackson的序列化规则, 将一些Long类型字段转化为字符串返回给前端, 这个时候我们自定义了一个@IdEncrpt注解 , 通过反射获取类的属性, 判断属性上是否添加了@IdEncrpt注解, 如果添加了 , 就会通过反射获取属性值, 转化为字符串
2. 在整合EMQ的时候 , 为了能够方便的接收订阅消息, 我们自定义了一个@Topic注解 , 作用在类上 , 之后我们通过反射获取类的字节码, 并且获取类上的@Topic注解, 读取到里面定义的主题 , 通过策略模式将不同主题的消息分发到不同的处理器中
3. 除了上述之外, 在我们项目开发中经常使用的一些框架, 例如 : Mybatis , Spring , SpringMVC 等, 以及一些常用的工具库 common-utils , hutool工具库等都大量使用到了反射机制



## 10. springboot模式是单例还是多例？有哪些作用域？我怎么修改为多例？

- 单例。

> `@Component`、`@Service`、`@Repository`等注解

- 作用域有五种常用的有`singeton`和`prototype`

- 如何使用？=> 使用`@Autowired`注解或者`ApplicationContext.getBean()`获取Bean

- 要修改为多例，需要添加注释`@Scope("prototype")`



## 11. Integer i1 = 127;Integer i2 = 127;i1==i2？Integer i3 = 128;Integer i4 = 128;i3==i4?   int a = 128;Integer b = 128;a==b？Integer i = 128和new一个有什么区别？

true，因为Integer会在缓存（Integer Cache）中保存-128~127的对象

false，超过了缓存范围

相等。基本数据类型int和Integer用`==`比较时，Integer会自动拆箱为int，然后进行数值比较。

>  [!tip]
>
>  建议使用`.equals()`进行比较`Integer`而不是`==`

`Integer i = 128`会自动装箱，超出缓存范围的会创建新对象，而`new Integer(128)`总是创建新的对象，不使用缓存机制



## 12. 接口和抽象类的区别

首先，从定义和实现的角度来说，接口只定义了方法签名，但是没有实现，实现类必须提供所有方法的实现；抽象类可以包含抽象方法和具体方法，子类需要实现抽象方法，可以继承具体方法。

从多来说继承性方面来说，接口支持多实现，一个类可以实现多个接口；抽象类不支持多继承，一个类只能继承一个抽象类。

还有接口只能定义常量，而且没有构造方法；抽象类可以定义普通成员变量和常量，也有构造方法，子类实例化的时候会调用。

适用场景：接口适合指定某一种标准或者规范，抽象类适合适合定义有继承关系的类层次结构



## 13. 说一下java的三大特性

多态:多态是指同一个接口或方法在不同的对象上有不同的实现方式。包括方法重载（编译时多态）和方法重写（运行时多态）。

封装:封装是将数据（属性）和操作数据的方法（行为）结合在一起，并对外隐藏对象的内部实现细节。通过访问修饰符（public、private、protected）来控制对类成员的访问权限。

继承:继承允许一个类（子类/派生类）获得另一个类（父类/基类）的属性和方法，实现代码重用。Java使用`extends`关键字实现继承。



## 14. 深拷贝和浅拷贝的区别？怎么实现深拷贝？

浅拷贝和深拷贝是对象复制的两种方式，区别在于处理引用类型属性时。

- **浅拷贝**：只复制基本类型（如int、String）的值，对于引用类型（如对象、数组），复制的是引用地址。新旧对象共享同一内存，修改一个会影响另一个。适合简单对象，但容易导致意外修改。Java中Object.clone()（native方法）默认是浅拷贝（需实现Cloneable接口）。
- **深拷贝**：复制整个对象图，包括所有引用类型的内部对象。新对象完全独立，修改不影响源对象。适合复杂嵌套对象，如项目中的用户对象（含设备列表）。数组也有深拷贝，不需要实现Cloneable接口。

### 如何实现深拷贝？

> [!tip] 
>
> 深度复制的方式：
>
> 1. **手动深度复制**：通过手动复制每个属性，确保引用类型的属性是通过新对象来复制。
> 2. **序列化**和**反序列化**：使用 `ByteArrayOutputStream` 和 `ObjectInputStream` 将对象转化为字节流，再反序列化回新对象，从而实现深度复制。性能差。
> 3. **工具库**：使用 Apache Commons Lang 提供的 `SerializationUtils` 来简化深度复制的实现。

---

1. 手动实现（推荐在性能敏感的场景中使用）

最直接的方式：**手写构造函数 / 工厂方法**复制所有字段，包括引用类型。

**优点：**

- 可控性强、性能高。
- 无需序列化依赖。

**缺点：**

- 对象字段多时代码冗长。
- 一旦类结构变动，要同步修改。

---

2. 实现 `Cloneable` 接口并重写 `clone()`

Java 自带的“拷贝接口”，但默认是**浅拷贝**，要自己递归修改成深拷贝。

**优点：**

- 不用引入额外库。
- 支持复杂嵌套结构。

**缺点：**

- `Cloneable` 本身设计不优雅。
- `clone()` 是受保护方法、语义混乱。
- 需要处理 `CloneNotSupportedException`。

> ✅ 实际项目中推荐自定义 `deepClone()` 方法而不是直接复用 `clone()`。

---

3.  通过序列化实现（最通用、但性能略低）

利用序列化的特性把对象完全转成字节流再还原，可实现真正意义上的深拷贝。

（1）Java原生序列化（`Serializable`）

- [x] 会不会触发构建方法

**不会**

**优点：**

- 代码最简单。
- 支持任意复杂对象结构。

**缺点：**

- 必须实现 `Serializable`。
- 性能较低。

~~（2）使用第三方库（如 Apache Commons Lang）~~

Apache Commons Lang 提供了 `SerializationUtils.clone()` 方法，内部也是序列化实现。

**优点：**

- 一行搞定。
- 简洁可靠。

**缺点：**

- 依赖外部库。

---

4. 使用 JSON 序列化（简便、兼容性强）

常用于前后端交互对象复制，比如用 `Jackson` 或 `Gson`。

**优点：**

- 简单直观。
- 不依赖 `Serializable`。
- 兼容多语言对象结构。

**缺点：**

- 序列化/反序列化性能一般。
- 丢失 transient 字段或类型信息（复杂泛型不建议）。



 ## 15.  stream流你熟悉吗？说一下常用的api？

熟悉。常用的一些api有map()对一些对象进行映射，collect()收集Stream流，filter对一些元素进行过滤，sorted()排序，distinct()去重，forEach()遍历循环元素，limit()取前几个元素，skip()跳过前几个元素，count()统计个数，还有最大值最小值max()、min()。大概这些常用的api。

- map()对一些对象的属性做映射
- filter()：按条件过滤元素
- distinct()：去重（依赖 `hashCode` 和 `equals`  => 引出重写`hashCode`和`equals`方法）
- limit(n)：截取前n个
- skip(n)：跳过前n个
- collect()：收集stream流
- forEach()：循环遍历元素
- sorted()：排序
- count()、max()、min()