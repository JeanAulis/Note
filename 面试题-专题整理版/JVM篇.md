[toc]

## 1. 说一下jvm的内存区域,以及每个区域是干什么的

> [!note] 
>
> JVM的内存区域整体可以分为三大部分：类加载器，运行时数据区，字节码执行器

其中——

第一，**类加载系统（Class Loader Subsystem）**：负责将`.class`文件从磁盘加载到内存中，并生成对应的Class对象。它分为启动类加载器、扩展类加载器、应用类加载器，形成双亲委派模型，保证类加载的安全性和唯一性。

第二，**字节码执行引擎（Execution Engine）**：负责执行加载到内存中的字节码。执行引擎包括解释器、JIT编译器（即时编译器）以及本地方法接口（JNI）。其中`native`关键字修饰的方法就是通过JNI调用底层C/C++实现的本地方法，用于让Java程序访问底层系统资源，比如`sleep()`、`wait()`、`hashCode()`等都可能涉及native实现。

第三，**运行时数据区（Runtime Data Area）**：这是JVM内存中最核心的部分，主要包括：

- **程序计数器（PC Register）**：每个线程独有，记录当前线程执行到的字节码行号指令地址，用于线程切换时恢复执行位置。
- **虚拟机栈（VM Stack）**：每个线程独有，保存局部变量、操作数栈、动态链接、方法出口等信息，主要用于方法调用。
- **本地方法栈（Native Method Stack）**：与虚拟机栈类似，只不过服务于native方法。
- **堆（Heap）**：所有线程共享，用于存放对象实例，是GC（垃圾回收器）的主要管理区域。
- **方法区（Method Area）**：存放已加载类的元数据（类结构、常量、静态变量、JIT编译后的代码等）。在JDK 8 之后，永久代（PermGen）被移除，改由**元空间（Metaspace）**取代，存放在本地内存中。

---



运行时数据区域：

- **程序计数器（PC Register）**

记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空），线程私有，用于线程切换后恢复执行位置。

>  [!warning] 
>
>  程序计数器是唯一一个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而**销毁**。




- **虚拟机栈（JVM Stack）**

线程私有，存储方法执行的栈帧（局部变量表、操作数栈、常量池引用等），用于方法调用和局部变量存储。

它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

<img src="./assets/image-20251007205322475.png" alt="image-20251007205322475" style="zoom:50%;" />





- **本地方法栈（Native Method Stack）**

线程私有，为本地方法（Native 方法 -> C、C++ 或汇编语言等）服务，功能类似虚拟机栈，它们之间的区别只不过是本地方法栈为本地方法服务，即区别是：**虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

- **堆（Heap）**

线程共享，所有对象都在这里分配内存，堆不需要连续内存，并且可以动态增加其内存，存储对象实例和数组，是垃圾回收的主要区域。

可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。

- **方法区（Method Area）**

线程共享，存储类信息、常量、静态变量等（JDK8 及以后由元空间实现）。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

- **运行时常量池**

方法区的一部分，存储编译期生成的字面量和符号引用。

- **直接内存**

非 JVM 内存区域，由 NIO 使用，减少数据拷贝。

> [!tip] 
>
> **线程私有的：**
>
> - 程序计数器
> - 虚拟机栈
> - 本地方法栈
>
> **线程共享的：**
>
> - 堆
> - 方法区
> - 直接内存 (非运行时数据区的一部分)



<img src="./assets/image-20251007194917149.png" alt="image-20251007194917149" style="zoom:67%;" />

<img src="./assets/image-20251007203810502.png" alt="Java 运行时数据区域（JDK1.7 ）" style="zoom:80%;" />

<img src="./assets/image-2025100720392053.png" alt="Java 运行时数据区域（JDK1.8 ）" style="zoom:80%;" />



## 2. 说一下常见的垃圾收集算法以及他们的特点是什么

> [!tip]
>
> 垃圾回收算法主要有三种常见的实现方式，分别是 **标记清除（Mark-Sweep）算法、标记整理（Mark-Compact）算法、复制（Copying）算法**。这三种算法的核心区别在于——**如何标记要保留的对象、以及在清理时如何处理内存碎片问题。**
>
> 第一，**标记-清除算法（Mark-Sweep）**。
> 它的过程分为两个阶段：**标记阶段**和**清除阶段**。
> 先通过“可达性分析算法”从GC Roots出发，标记所有仍然可达、不能被回收的对象，也就是“活对象”。然后在清除阶段，清理掉未被标记的对象，释放它们所占的内存。
> 优点是实现简单、执行速度相对较快；缺点是会产生大量**内存碎片**，导致无法为大对象分配连续内存区域。
>
> 第二，**标记-整理算法（Mark-Compact）**。
> 它是在标记-清除的基础上改进的。
> 同样先标记出活对象，但在清除阶段，不是直接清理死亡对象，而是把所有存活的对象**往内存的一端移动**，使它们排列连续，然后再清理掉边界之外的空间。
> 优点是**不会产生内存碎片**，适合需要分配大对象的场景；缺点是因为要移动对象，所以**性能开销比标记清除大**。
>
> 第三，**复制算法（Copying）**。
> 这种算法会把内存分为两块大小相等的区域（如From区与To区）。
> 每次只使用其中的一块来分配对象，当这块空间快满时，就执行GC：标记出仍存活的对象，并把它们复制到另一块空的区域中，然后直接清空原来的整块空间。
> 优点是回收效率高、没有碎片问题；缺点是**内存利用率低**（只有一半空间能被实际使用）。

> 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。



## 3. 说一下常见的垃圾收集器以及他们的特点是什么

<img src="./assets/image-20251007211635888.png" alt="image-20251007211635888" style="zoom: 67%;" />

以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。

> gc线程是守护线程

> [!note]
>
> **串行垃圾收集器**：
> 只有一个GC线程，在GC过程中所有用户线程都会暂停（Stop The World）。优点是实现简单；缺点是停顿时间长，用户体验差。（年轻代老年代都可以用）
>
> **并行垃圾收集器**：
> 在串行的基础上引入了多个GC线程并行工作，减少了STW的时间。优点是效率更高；缺点是依然需要暂停用户线程。（年轻代老年代都可以用）
>
> **CMS垃圾收集器**：
> 第一个支持用户线程和GC线程并发执行的收集器，采用标记清除算法。优点是STW时间更短，用户体验更好；缺点是会产生内存碎片，并且在某些阶段仍然会触发STW，甚至退化为串行收集。（一般只会作用在老年代）
>
> **G1垃圾收集器**：
> 在CMS的基础上改进，可自行设定最大停顿时间（如100ms），超过时间未完成的垃圾会留到下一次回收。优点是可控停顿时间、回收更灵活；缺点是实现复杂，调优较难。

> [!important]
>
> 目的是调优，减少STW的时间
>
> 垃圾收集器的发展历程，就是JVM不断在“高吞吐”和“低停顿”之间寻找平衡的过程。串行最简单，Parallel追求速度，CMS追求低停顿，G1则在效率与延迟控制之间取得了工程化平衡。

> [!important]
>
> 小内存（8G～16G以内）系统：常用**串行 + CMS**组合，年轻代高效并行，老年代减少停顿。
>
> 大内存（几十G以上）系统：主流选择**G1 GC**，因为G1能同时处理新生代与老年代，且具备延迟控制能力。



---

> 常见的垃圾收集器有以下四种大类型：
>
> - 串行垃圾收集器：SerialGC、SerialOldGC（守护线程）使用单线程进行垃圾回收，堆内存较小，适合个人电脑，同时在垃圾回收时，只有一个线程在工作，而且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
> - 并行垃圾收集器：ParallelOldGC、ParNewGC。垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
> - CMS(并发）垃圾收集器：CMSGC，作用在老年代。CMS是多线程、以获取最短回收停顿时间为目标的老年代收集器，主要是运用标记清除算法。其最大特点是在进行垃圾回收时，应用仍然能正常运行。
> - G1垃圾收集器：作用在新生代和老年代

> [!note] 
>
> **Serial 收集器**：单线程，适用于单CPU环境，简单高效。新生代用标记-复制，老年代用标记-整理。适合小型应用。
>
> **ParNew 收集器**：Serial的多线程版，仅作用于新生代，常与CMS配合，适合多核环境。
>
> **Parallel Scavenge 收集器**：多线程，注重吞吐量，适用于后台任务，仅作用于新生代，支持自适应调节。
>
> **Serial Old 收集器**：Serial的老年代版本，单线程，标记-整理算法，适用于Client模式或CMS后备。
>
> **Parallel Old 收集器**：Parallel Scavenge的老年代版本，多线程，标记-整理算法，适合吞吐量优先场景。
>
> **CMS 收集器**：并发标记清除收集器，目标低停顿，适用于老年代，基于标记-清除算法，易产生碎片，JDK 9后废弃。
>
> **G1 收集器**：面向服务端，分区管理，兼顾新生代和老年代，结合标记-复制和标记-整理算法，支持可预测停顿，JDK 9后默认。

**1. Serial 收集器**

它是**单线程的收集器**，只会使用一个线程进行垃圾收集工作。

它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

**2. ParNew 收集器**

它是 Serial 收集器的**多线程版本**。

它是许多运行在 Server 模式下的虚拟机的首要选，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。（Serial收集器也可以，但通常用于Client模式）

> [!caution] 
>
> **ParNew 只作用于新生代，不涉及老年代**

**3. Parallel Scavenge 收集器**

与 ParNew 一样是**多线程收集器**。

其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。

**4. Serial Old 收集器**

是 Serial 收集器的老年代版本，是一个**单线程收集器**，也是给 Client 场景下的虚拟机使用。两大用途：

- 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。

Serial Old 使用**标记-整理算法**

**5. Parallel Old 收集器**

是 Parallel Scavenge 收集器的老年代版本。**多线程**

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

**6. CMS 收集器**

CMS全称ConcurrentMarkSweep，CMS是**多线程**、以获取最短回收停顿时间为目标的老年代收集器，主要是运用标记清除算法。其最大特点是在进行垃圾回收时，应用仍然能正常运行。

**CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。**

CMS在某些阶段（如初始标记、最终标记）是单线程的

**7. G1 收集器**

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

G1被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。

应用于新生代和老年代，在jdk9之后默认使用G1，分成多个区域，新生代和老年代不再物理隔离，每个区域都可以充当eden，survivor，old，humongous，其中humongous专为大对象准备，用复制算法（避免碎片化，响应时间与吞吐量兼顾）；G1 可以直接对新生代和老年代一起回收。

G1算法：

- **新生代**：复制算法

- **老年代**：标记-整理算法（Mixed GC 时）


| 收集器            | 作用区域 | 线程       | 算法           | 目标       | 状态            |
| ----------------- | -------- | ---------- | -------------- | ---------- | --------------- |
| Serial            | 新生代   | 单线程     | 标记-复制      | 单线程效率 | 仍可用          |
| Serial Old        | 老年代   | 单线程     | 标记-整理      | CMS 后备   | 仍可用          |
| ParNew            | 新生代   | 多线程     | 标记-复制      | 配合 CMS   | 基本弃用        |
| Parallel Scavenge | 新生代   | 多线程     | 标记-复制      | 吞吐量     | 仍可用          |
| Parallel Old      | 老年代   | 多线程     | 标记-整理      | 吞吐量     | 仍可用          |
| CMS               | 老年代   | 多线程并发 | 标记-清除      | 低停顿     | JDK 14 移除     |
| G1                | 全堆     | 多线程并发 | 标记-复制/整理 | 可预测停顿 | **JDK 9+ 默认** |

## 4. 说一下cms的各个阶段过程以及特点(5个阶段)

// TODO 差总结，精炼版

分为以下四个流程：

- **初始标记：** 短暂停顿，标记直接与 root 相连的对象（根对象）；(非并发)
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。

具有以下缺点：

- 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。
- 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。
- 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

## 5. 说一下G1的各个阶段过程以及特点

// TODO 差总结，精炼版

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

- **初始标记**： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象
- **并发标记**：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。
- **最终标记**： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。
- **筛选回收**：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度。

具备如下特点：

- 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。



## 6. 你们项目是用哪一个垃圾收集器,为什么用这个?

在生产环境下，组长当时配置了JVM参数，据我了解，当时我们那个项目使用的是G1垃圾收集器， 因为当时我们单节点分配的内存有点大是16GB或者32GB，所以我们选择了G1垃圾收集器。

> [!tip] 
>
> 项目通常使用**G1收集器**，原因：
>
> - 适合大内存应用，堆大小通常超过4GB。
> - 提供可预测的暂停时间，满足交互式应用的低延迟需求。
> - 自动分区管理，减少内存碎片。
> - 相比CMS，G1更现代化，维护成本低。



## 7. 什么样的对象会被成为垃圾对象

没有任何引用指向的对象，即不可达对象。

如果要定位什么是垃圾，有两种方式来确定，第一个是引用计数法，第二个是可达性分析算法。

- 被强引用关联的对象不会被回收。
- 被软引用关联的对象只有在内存不够的情况下才会被回收。
- 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
- 又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。



## 8. 说一下双亲委派机制以及优点

<img src="./assets/image-20251007220653292.png" alt="image-20251007220653292" style="zoom:67%;" />

双亲委派模型并不是一种强制性的约束，只是 JDK 官方推荐的一种方式。如果我们因为某些特殊需求想要打破双亲委派模型，也是可以的。

> [!note] 
>
> **双亲委派机制**：
>
> - 类加载器收到加载请求后，先委托父加载器（ClassLoader）加载，父加载器无法加载时才尝试自己加载。
> - 加载器层级（从根到叶）：启动类加载器 → 扩展类加载器 → 应用程序类加载器 → 自定义加载器。 
>
> **优点**：
>
> - 避免**类重复加载**，保证类唯一性。
> - 提供安全保障，防止核心类（如java.lang.Object）被篡改。
> - 提高加载效率，优先使用系统类。

执行流程：

- 在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。



## 9. 说一下常用的jvm参数有哪些,分别是代表什么意思

**内存**

8G的实例，分到JVM的就4G左右

`-Xms` 含义： JVM 启动时申请的初始堆内存大小。`-Xms512m` 表示初始堆内存为 512 MB。

- 影响应用启动速度和初期性能，通常建议设置成和 `-Xmx` 相同值，避免运行时堆动态扩展导致额外开销。

`-Xmx `含义： JVM 可以使用的最大堆内存大小。`-Xmx4g` 表示最大堆内存为 4 GB。

-  最关键参数之一！直接决定了应用允许创建对象的极限空间。设置过小易引发 `OOM: Java heap space`。

**垃圾回收器**

`-XX:+Use[GCName]GC `(选择收集器)：核心开关参数，指定使用哪种 。`-XX:+UseG1GC`：启用 G1 收集器 。

**垃圾回收日志**

`-Xloggc`:**含义：** 将 GC 日志输出到**指定文件**。（**示例：** `-Xloggc:/var/log/myapp/gc.log` ）

`-XX:+PrintGCDetails`：打印GC日志。

**其它**

`-D`：**含义：** **设置 Java 系统属性。示例：** `-Dserver.port=8081` (设置应用端口)



## 10. 四大引用分别是什么,代表什么意思

- **强引用**：普通引用（如Object obj = new Object()），GC不会回收。
- **软引用（SoftReference）**：只有在内存不够的情况下才会被回收，适合缓存。
- **弱引用（WeakReference）**：下次GC时必被回收，适合临时对象。
- **虚引用（PhantomReference）**：不影响对象生命周期，用于跟踪对象被GC回收的时机。唯一目的是能在这个对象被回收时收到一个系统通知。
  - **虚引用与软引用和弱引用的一个区别在于：**虚引用必须和引用队列（ReferenceQueue）联合使用。



## 11. 什么是内存溢出,什么是内存泄漏

- **内存溢出（OutOfMemoryError）**：内存不足以分配新对象，会先尝试GC一次或多次，还不够的话，才会内存溢出，如堆、栈或方法区溢出。
- **内存泄漏**：无用对象未被GC回收，持续占用内存，可能导致内存溢出。



## 12. 你的项目中出现过内存溢出吗?你是怎么排查并且解决的

服务器太拉，内存不够；全表查询，堆溢出；递归，栈溢出，方法区溢出；Excel导入导出，~~上传可以避免OOM，下载（导出）没办法避免OOM~~

> [!important]
>
> Excel导入导出，查询数据库中的表，没有分页；并发高都可能会有OOM

首先可以通过jmap指定打印他的内存快照 dump文件，不过有的情况打印不了，我们会设置jvm参数让程序自动生成dump文件

第二，可以通过工具去分析 dump文件，jdk自带的VisualVM就可以分析

第三，通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题

第四，找到对应的代码，通过阅读上下文的情况，进行修复即可



## 13. 怎么解决cpu高

首先可以使用使用top命令查看占用cpu的情况

第二通过top命令查看后，可以查看是哪一个进程占用cpu较高，记录这个进程id

第三可以通过ps 查看当前进程中的线程信息，看看哪个线程的cpu占用较高

第四可以jstack命令打印进行的id，找到这个线程，就可以进一步定位问题代码的行号

> [!tip] 
>
> **常见原因**：
>
> - 死循环或复杂计算逻辑。
> - 频繁GC导致CPU占用。



## 14. 你有做过jvm调优吗

> [!important] 
>
> **没做过**



使用 JDK 自带的`jvisualvm`分析 dump 文件(MAT 也能分析)。

**通过观察 GC 频率和停顿时间，来进行 JVM 内存空间调整，使其达到最合理的状态。调整过程记得小步快跑，避免内存剧烈波动影响线上服务。**

有，涉及下面这些方面：

- **堆大小调整**：设置-Xms和-Xmx一致，避免动态扩展。
- **GC优化**：选择G1或CMS，调整-XX:MaxGCPauseMillis或-XX:NewRatio。
- **监控与日志**：开启-XX:+PrintGCDetails，分析GC性能。
- **栈大小调整**：设置-Xss减少线程栈内存占用。 **结果**：减少GC暂停时间，提高系统吞吐量或响应速度。



## 15. 配置文件的优先级

命令行参数 → application.properties → application.yml → application.yaml → bootstrap.properties/.yml/.yaml → 配置中心（如 Nacos、Apollo、Spring Cloud Config） → 环境变量（如 JAVA_OPTS、SPRING_APPLICATION_JSON） → JVM 默认配置

