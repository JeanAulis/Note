# 10月15号

## （1）说一下哨兵集群的作用是什么？

哨兵（Sentinel）集群是一种高可用性的解决方案，主要的作用有：

1. 监控：持续检查主服务器和从服务器是否正常运行
2. 通知： 当被监控的 Redis 实例发生故障时，Sentinel 可以通过 API 向其他应用程序或管理员发送通知。
3. 自动故障转移：
   - 当主服务器宕机时，Sentinel 之间会进行协商，投票选出一个 Sentinel 来执行故障转移。
   - 选中的 Sentinel 会在众多的从服务器中，通过一系列策略（如优先级、复制偏移量等）选举出一个新的主服务器（`slaveof no one`）。
   - 让其他从服务器去复制新的主服务器（`slaveof <new-master-ip> <new-master-port>`）。
   - 当故障的主服务器重新上线时，它会被自动配置为新主服务器的从服务器。
4. **配置提供者（Configuration Provider）：** 客户端连接到 Sentinel 实例，获取当前正确的主服务器的地址。即使主服务器发生了切换，客户端也能通过 Sentinel 及时获取到新的主服务器信息。



## （2）说一下什么是主观下线和客观下线

1. 主观下线（Subjectively Down, SDown）：如果某sentinel节点发现某实例未在规定时间响应,则认为该实例主观下线。
2. 客观下线:若超过指定数量(quorum)的sentinel都认为该实例主观下线,则该实例客观下线。quorum值最好超过Sentinel实例数量的一半。



## （3）你在项目中哪里用到了es？用来做什么？如何保证es和数据库的一致性？

全文检索：用来做一个微商城的商品模糊查询

多维度过滤/聚合：可以根据医疗设备/耗材的类型，品牌，价格区间，以及发货地等进行筛选

           

1. 同步双写（简单/低并发）
   - 在更新数据库事务成功后，立即同步调用 ES 的更新 API。

2. 项目使用了Canal+MQ的方式进行索引同步。

- Canal会定时读取数据库的binlog日志，解析出增加、修改及删除的数据内容并将其写入MQ。

- 同步程序监听MQ，收到消息后根据消息内容请求ES同步索引数据。

- 这里最关键的问题是MQ的消息可靠性，我们是这样保证MQ的消息可靠性的。


> ### Canal是怎么伪装成 MySQL slave？
>
> 1、Canal模拟 MySQL 从库的交互协议，伪装自己为 MySQL slave ，向 MySQL master 发送dump 协议
>
> 2、MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal )
>
> 。一旦连接建立成功，Canal会一直等待并监听来自MySQL主服务器的binlog事件流，当有新的数据库变更发生时MySQL master主服务器发送binlog事件流给Canal。
>
> 3、Canal会及时接收并解析这些变更事件并解析 binary log 
>
> ### 如何保证Canal+MQ同步消息的顺序性？
>
> Canal解析binlog日志信息按顺序发到MQ的队列中。
>
> 现在是要保证消费端如何按顺序消费队列中的消息。
>
> 解决方法：
>
> 只安排一个消费者消费，~~预缓存，concurrency都为1~~
>
> 只有一个节点没有高可用，如果挂掉？-> 项目暂时没有这个场景，如果有消费者集群的话
>
> 使用**分区有序** - > 分多个队列，使用hash并取模，每个队列一个消费者



## （4）说一下es倒排索引的底层原理？

> [!tip] 
>
> -  **正向索引**是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是**根据文档找词条的过程**。 
> -  而**倒排索引**则相反，倒排索引的概念是基于MySQL这样的正向索引而言的。是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是**根据词条找文档的过程**。 
>
> **正向索引**：
>
> - 优点： 
>  - 可以给多个字段创建索引
>   - 根据索引字段搜索、排序速度非常快
> 
>- 缺点： 
>   - 根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。
>
> 
>**倒排索引**：
> 
>- 优点： 
>   - 根据词条搜索、模糊搜索时，速度非常快
>
> - 缺点： 
>  - 只能给词条创建索引，而不是字段
>   - 无法根据字段做排序
>

倒排索引的建立过程是：

- 将每一个文档的数据利用**分词算法**根据语义拆分，得到一个个词条
- 倒排索引记录每个词条对应的文档id

搜索的过程是：

- 对输入的关键字进行分词，得到一个一个的词条
- 拿词条去倒排索引中查找，找到词对应的文档id
- 将所有匹配的文档id合并为结果集。

在 Elasticsearch 中，倒排索引是用来支持全文检索的核心数据结构。
它将“词项”映射到“文档ID列表”，底层基于 Lucene 实现，由 **Term Dictionary（FST 实现）** 和 **Posting List（文档列表）** 组成。
每个分片（Shard）对应一个 Lucene 索引，Lucene 再由多个 Segment 构成，每个 Segment 就是一份独立的倒排索引。
查询时，ES 会对搜索词进行分词，然后根据倒排表找到命中的文档ID，并使用 BM25 等算法计算相关度排序。
倒排索引极大提升了全文检索的性能，是 Elasticsearch 能够在海量文本中实现毫秒级搜索的关键。



## （5）说一下match和term的区别

**`term` 查询是精确匹配查询**，而 **`match` 查询是全文检索查询**。

- `term` 查询不会对查询条件进行分词，直接拿整个字符串去和倒排索引中的词条做完全匹配。一般用于结构化数据查询，比如：ID、城市、品牌、状态、分类字段等。查询适用于 keyword 类型字段，强调**完全一致**。

- `match` 查询会根据字段的 analyzer 对查询字符串进行分词，然后逐个词条去匹配倒排索引。一般用于 text 类型字段的模糊搜索，例如名称、标题、描述、内容等。查询适用于 text 类型字段，强调**相关性匹配（模糊搜索）**。
