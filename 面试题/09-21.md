# 9月21号

## （1）事务的传播行为有哪些？require_news一般用在什么场景？

## （2）首先说一下导致事务失效有哪些场景？


## （3）场景题：有一个类，当中有ab两个方法：

第一种情况：a加了@Transactional，b加了@Transactional(propagation = Propagation.REQUIRES_NEW)，然后a方法内部会调用b方法，这时候外部调用a方法，这时候b方法抛出异常，a方法会回滚吗？反过来a方法抛出异常，b方法会回滚吗？为什么？

第二种情况：基本情况同上，a没有加@Transactional，b加了@Transactional，这时候外部调用a方法，b方法抛出了异常的话，b方法会回滚吗？

## （4）你知道哪些常用的排序算法和时间复杂度吗？你说一下快排的思路?

## （5）说一下http和https的区别









### （1）事务的传播行为有哪些？`REQUIRES_NEW`一般用在什么场景？



------

事务的传播行为（**Propagation Behavior**）定义了当一个方法在一个已有的事务中被调用时，它应该如何参与或创建事务。Spring框架中常用的事务传播行为包括：

- **`REQUIRED`**：这是默认行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **`SUPPORTS`**：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
- **`MANDATORY`**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
- **`NEVER`**：以非事务方式执行，如果当前存在事务，则抛出异常。
- **`NOT_SUPPORTED`**：以非事务方式执行，如果当前存在事务，则将其挂起（**suspend**）。
- **`REQUIRES_NEW`**：**创建一个新的事务**，并且**挂起**当前已有的事务。
- **`NESTED`**：如果当前存在事务，则创建一个**嵌套（nested）事务**，这个嵌套事务是外部事务的一部分。如果外部事务回滚，嵌套事务也会回滚。但嵌套事务可以独立于外部事务进行部分回滚。如果当前没有事务，则创建一个新事务，行为类似于 `REQUIRED`。

**`REQUIRES_NEW`** 的常用场景是：

- **日志记录或监控**：在主业务逻辑失败时，你仍然需要确保记录日志的操作能够成功提交，不被主事务的回滚所影响。
- **独立子操作**：某个操作（如发送邮件、短信通知）即使主业务失败也必须成功，或者需要独立于主业务进行提交或回滚。
- **解耦**：当需要确保某个子操作的原子性，且不希望它的失败影响到外部主事务，或者它的成功不依赖于主事务的提交。



### （2）首先说一下导致事务失效有哪些场景？



------

事务失效（**Transaction Ineffectiveness**）通常是由于开发者在使用 Spring 事务注解 `@Transactional` 时，没有遵循其内部工作原理而导致的。常见场景包括：

- **非`public`方法**：`@Transactional` 注解只对 **`public`** 方法生效。这是因为 Spring AOP（面向切面编程）的动态代理机制是基于接口或类的，只有 `public` 方法才会被代理拦截。如果你的方法是 `protected`、`private` 或默认（包私有）访问修饰符，事务将不会生效。
- **在同一个类中调用**：当一个被 `@Transactional` 注解的方法被其**同一个类内部**的另一个方法调用时，事务会失效。这是因为`a.b()`这种**内部调用**本质上是`this.b()`，它会绕过 Spring AOP 的代理对象，直接调用原始对象的方法，因此事务代理不会起作用。
- **捕获了异常但没有抛出**：如果 `@Transactional` 方法内部抛出了异常，但是你使用 `try...catch` 块捕获了它，并且没有重新抛出（`throw`），Spring 就不会感知到这个异常，因此事务无法回滚。默认情况下，Spring 只对**运行时异常**（`RuntimeException`）和 **`Error`** 进行回滚。
- **错误的`rollbackFor`配置**：如果你需要对**检查型异常**（**Checked Exception**，如`IOException`、`SQLException`）进行回滚，但没有在 `@Transactional` 中显式配置 `rollbackFor = Exception.class`，那么事务在遇到这类异常时也不会回滚。
- **数据库引擎不支持事务**：例如，MySQL 的 `MyISAM` 存储引擎不支持事务，只有 `InnoDB` 引擎才支持。



### （3）场景题



------

**第一种情况：`a`加了`@Transactional`，`b`加了`@Transactional(propagation = Propagation.REQUIRES_NEW)`，`a`调用`b`，外部调用`a`**

- **`b`方法抛出异常，`a`方法会回滚吗？**
  - **会**。
  - **原因**：当外部调用 `a` 方法时，`a` 方法开启一个事务T1。当 `a` 调用 `b` 时，由于 `b` 的传播行为是 `REQUIRES_NEW`，Spring 会**挂起**T1，并为 `b` 创建一个新的事务T2。如果 `b` 抛出异常，T2会回滚，异常会向上传播。当异常被 `a` 方法捕获，`a` 所在的T1事务也会被标记为回滚（rollback-only），因为外部异常的传播，T1最终也会回滚。
- **反过来`a`方法抛出异常，`b`方法会回滚吗？**
  - **会**。
  - **原因**：`b`是在和`a`同一个类被`a`调用，所以并不会被AOP拦截，`b`事务并不会生效，故`b`不会被回退

**第二种情况：`a`没有加`@Transactional`，`b`加了`@Transactional`，`a`调用`b`，外部调用`a`**

- **`b`方法抛出了异常的话，`b`方法会回滚吗？**
  - **不会**。
  - **原因**：`b`是在和`a`同一个类被`a`调用，所以并不会被AOP拦截，`b`事务并不会生效，故`b`不会被回退



### （4）你知道哪些常用的排序算法和时间复杂度吗？你说一下快排的思路?



------

常用排序算法分为两种：

- 高级排序：快速排序、归并排序、堆排序，时间复杂度为O(nlogn)。
- 简单排序：冒泡排序、插入排序、选择排序，时间复杂度为O(n²)。补充说明：快速排序最坏情况为O(n²)，冒泡和插入排序最好情况为O(n)，高级排序适合大数据量，简单排序适合小规模或近有序数据。

**快速排序的思路：**

快速排序是一种**分治（Divide and Conquer）**算法。其基本思想是：

1. **选择基准（Pivot）**：从待排序的数组中选取一个元素作为基准值。
2. **分区（Partition）**：将数组中除基准值外的所有元素进行分区，使得所有比基准值**小**的元素都移动到它的**左边**，所有比基准值**大**的元素都移动到它的**右边**。
3. **递归（Recursion）**：对基准值左边和右边两个子数组**重复执行**上述两个步骤，直到子数组的长度为1或0，无法再进行分区。

这个过程会不断递归地将数组划分为更小的子数组，直到所有元素都处于正确的位置，最终完成排序。



### （5）说一下HTTP和HTTPS的区别



------

| 特性           | **HTTP**（HyperText Transfer Protocol） | **HTTPS**（HyperText Transfer Protocol Secure）              |
| -------------- | --------------------------------------- | ------------------------------------------------------------ |
| **安全性**     | **不安全**，传输的数据是明文。          | **安全**，通过 SSL/TLS 协议对数据进行加密。                  |
| **连接方式**   | 客户端与服务器之间直接建立连接。        | 在 HTTP 连接的基础上，通过 **SSL/TLS** 握手过程，在客户端和服务器之间建立加密通道。 |
| **端口号**     | 默认端口是**80**。                      | 默认端口是**443**。                                          |
| **证书**       | 不需要任何证书。                        | 需要 **SSL/TLS 数字证书**来验证服务器身份。                  |
| **性能**       | 性能开销小，传输速度快。                | 增加了 SSL/TLS 握手和数据加解密的过程，性能开销相对较大。    |
| **中间人攻击** | 容易被中间人攻击者窃取、篡改数据。      | SSL/TLS 协议能有效防止中间人攻击，保证数据的完整性和机密性。 |
