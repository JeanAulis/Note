# 9月29号

## （1）说一下雪花算法id的组成及每个部分的作用？怎么解决时钟回拨的问题？

雪花算法（Snowflake）是一种生成分布式唯一ID的算法，它生成的ID是一个64位的整数（标准64位二进制，也有32位）。这个ID的组成结构如下：

- **1位：符号位** - 永远为0，因为ID都是正数，所以这一位不使用。
- **41位：时间戳** - 精确到毫秒，可以存储约69年的时间。这部分是ID的主体，保证了ID的递增性。
- **10位：工作机器ID** - 可以有1024个机器（节点），通常由5位数据中心ID和5位工作机器ID组成，用于区分不同的机器。
- **12位：序列号** - 同一毫秒内，在同一台机器上可以生成的ID数量，可以有4096个（0~4095）。(atomInteger原子性)

> [!tip]
>
> 叶子算法

**作用：**

- **全局唯一性**：通过机器ID和序列号保证了在分布式系统中的唯一性。
- **递增性**：由于时间戳部分是递增的，生成的ID也是大致递增的，这对于一些数据库（如MySQL）的索引优化非常有利。
- **高可用性**：不依赖于中心化的服务，每个节点都可以独立生成ID。
- **时间有序性**：可以根据ID反向解析出其生成的大致时间。

------

**如何解决时钟回拨问题：**

时钟回拨是雪花算法面临的一个主要挑战。如果服务器时间发生了回拨，可能导致生成的ID重复。解决这个问题有几种策略：

1. ~~**直接拒绝服务**：当检测到当前时间小于上次记录的时间时，直接抛出异常并拒绝生成ID，等待时间同步。这是最简单、最安全的方法，但会导致服务暂时不可用。~~
2. ~~**等待时间追上**：当发现时钟回拨时，线程会暂停，一直等到当前时间追上或超过上次记录的时间，然后再继续生成ID。这种方法可以保证ID的唯一性，但可能会导致延迟。~~
3. ~~**使用备用序列号（高位）**：引入一个备用序列号，在时钟回拨期间，使用备用序列号来生成ID。当时间追上或超过时，再切换回正常模式。~~
4. ~~**记录上次时间并警告**：记录下上次的时间戳，如果发现回拨，可以记录警告日志，但仍然继续使用旧的时间戳生成ID。这种方式可能导致在回拨期间生成的ID时间戳看起来是错误的，但在绝大多数情况下是唯一的。~~



为什么Mysql主键要用自增的数字，不使用UUID，而是使用雪花算法生成的id呢？





## （2）说一下mysql的主从复制原理？

MySQL主从复制是一种将一个MySQL数据库实例（主库）的数据变更，同步到另一个或多个数据库实例（从库）的技术。其核心原理是基于MySQL的**二进制日志（binlog）**。

复制过程主要有三个线程：

- **主库I/O线程（Binlog Dump Thread）**：当从库连接上来时，主库会创建一个I/O线程，将**binlog event**（数据变更事件）发送给从库。
- **从库I/O线程（Replica I/O Thread）**：从库连接到主库后，会创建该线程。它负责接收主库I/O线程发过来的binlog event，并将这些事件写入到从库本地的**Relay Log（中继日志）**中。
- **从库SQL线程（Replica SQL Thread）**：该线程负责读取**Relay Log**中的事件，并逐一在从库上执行，从而实现数据的同步。

**基本流程：**

1. **开启binlog**：主库必须开启binlog功能，记录所有的数据修改操作。
2. **从库连接**：从库配置好主库的地址、端口、用户名密码等信息后，连接到主库。
3. **主库发送binlog**：主库I/O线程开始将binlog内容发送给从库。
4. **从库接收和写入**：从库I/O线程接收binlog并写入到本地的Relay Log中。
5. **从库执行**：从库SQL线程读取Relay Log，并在从库上执行相同的SQL语句。



Mysql读写分离，读不到怎么解决？

- Mybatis手动指定读的数据库
- Mysql高版本支持配置sql多线程加快relay log落库

为什么低版本不支持？







## （3）说一下mysql有哪些日志文件？

MySQL有多种重要的日志文件，它们用于不同的目的：

- **错误日志（Error Log）**：记录MySQL服务器的启动、关闭、运行中的错误、警告信息。这是诊断MySQL故障的首要文件。
- **二进制日志（Binary Log / Binlog）**：记录所有对数据库的**数据变更**操作，如`INSERT`、`UPDATE`、`DELETE`、`DDL`等。它不记录`SELECT`等查询操作。Binlog是MySQL主从复制和数据恢复（基于时间点的恢复）的基础。

事务、主从复制

有多少种格式？





- ~~**查询日志（General Query Log）**：记录所有**接收到的SQL语句**，包括查询、写入、连接等。开启该日志会产生大量数据，通常只用于调试。~~
- **慢查询日志（Slow Query Log）**：记录执行时间超过指定阈值的SQL语句。它是数据库性能优化的重要工具。



- **重做日志（Redo Log）**：是InnoDB存储引擎特有的日志。它记录了**事务的物理变更**，用于保证事务的持久性（Durability）。即使系统崩溃，也可以通过Redo Log恢复到崩溃前的状态。buffer pool
- **回滚日志（Undo Log）**：也是InnoDB特有。它记录了数据修改前的状态，用于事务回滚和MVCC（多版本并发控制）。



## （4）说一下redis有哪些持久化策略？

Redis提供了两种主要的持久化策略来防止数据丢失：

1. **RDB（Redis Database）**：**快照持久化**。它会在指定的时间间隔内，将内存中的所有数据进行快照存储，生成一个**RDB文件**（`dump.rdb`）。
   - **优点**：
     - 对性能影响小，因为在进行快照时，可以fork一个子进程来处理。
     - RDB文件紧凑，适合备份和灾难恢复。
   - **缺点**：
     - 可能造成数据丢失，因为它是定时快照，如果在两次快照之间Redis崩溃，那么这期间的数据就没了。
     - fork子进程会消耗一定的系统资源。
2. **AOF（Append-Only File）**：**增量持久化**。它以日志的形式记录所有**写命令**。Redis会将接收到的每个写命令追加到AOF文件末尾。
   - **优点**：
     - **数据更完整**：可以配置不同的同步策略（如每秒同步），数据丢失的风险很低。
     - AOF文件是可读的，方便进行日志分析和恢复。
   - **缺点**：
     - AOF文件通常比RDB文件大，恢复速度相对较慢。
     - 对性能有一定影响，因为每次写操作都需要记录。



## （5）你项目中哪里用到了分布式锁？说一下分布式锁redisson的底层原理？

















### **1. 雪花算法ID的组成及作用 & 如何解决时钟回拨**



雪花算法（Snowflake）是一种生成分布式唯一ID的算法，它生成的ID是一个64位的整数。这个ID的组成结构如下：

- **1位：符号位** - 永远为0，因为ID都是正数，所以这一位不使用。
- **41位：时间戳** - 精确到毫秒，可以存储约69年的时间。这部分是ID的主体，保证了ID的递增性。
- **10位：工作机器ID** - 可以有1024个机器（节点），通常由5位数据中心ID和5位工作机器ID组成，用于区分不同的机器。
- **12位：序列号** - 同一毫秒内，在同一台机器上可以生成的ID数量，可以有4096个（0~4095）。

**作用：**

- **全局唯一性**：通过机器ID和序列号保证了在分布式系统中的唯一性。
- **递增性**：由于时间戳部分是递增的，生成的ID也是大致递增的，这对于一些数据库（如MySQL）的索引优化非常有利。
- **高可用性**：不依赖于中心化的服务，每个节点都可以独立生成ID。
- **时间有序性**：可以根据ID反向解析出其生成的大致时间。

------

**如何解决时钟回拨问题：**

时钟回拨是雪花算法面临的一个主要挑战。如果服务器时间发生了回拨，可能导致生成的ID重复。解决这个问题有几种策略：

1. **直接拒绝服务**：当检测到当前时间小于上次记录的时间时，直接抛出异常并拒绝生成ID，等待时间同步。这是最简单、最安全的方法，但会导致服务暂时不可用。
2. **等待时间追上**：当发现时钟回拨时，线程会暂停，一直等到当前时间追上或超过上次记录的时间，然后再继续生成ID。这种方法可以保证ID的唯一性，但可能会导致延迟。
3. **使用备用序列号（高位）**：引入一个备用序列号，在时钟回拨期间，使用备用序列号来生成ID。当时间追上或超过时，再切换回正常模式。
4. **记录上次时间并警告**：记录下上次的时间戳，如果发现回拨，可以记录警告日志，但仍然继续使用旧的时间戳生成ID。这种方式可能导致在回拨期间生成的ID时间戳看起来是错误的，但在绝大多数情况下是唯一的。

------



### **2. MySQL主从复制原理**



MySQL主从复制是一种将一个MySQL数据库实例（主库）的数据变更，同步到另一个或多个数据库实例（从库）的技术。其核心原理是基于MySQL的**二进制日志（binlog）**。

复制过程主要有三个线程：

- **主库I/O线程（Binlog Dump Thread）**：当从库连接上来时，主库会创建一个I/O线程，将**binlog event**（数据变更事件）发送给从库。
- **从库I/O线程（Replica I/O Thread）**：从库连接到主库后，会创建该线程。它负责接收主库I/O线程发过来的binlog event，并将这些事件写入到从库本地的**Relay Log（中继日志）**中。
- **从库SQL线程（Replica SQL Thread）**：该线程负责读取**Relay Log**中的事件，并逐一在从库上执行，从而实现数据的同步。

**基本流程：**

1. **开启binlog**：主库必须开启binlog功能，记录所有的数据修改操作。
2. **从库连接**：从库配置好主库的地址、端口、用户名密码等信息后，连接到主库。
3. **主库发送binlog**：主库I/O线程开始将binlog内容发送给从库。
4. **从库接收和写入**：从库I/O线程接收binlog并写入到本地的Relay Log中。
5. **从库执行**：从库SQL线程读取Relay Log，并在从库上执行相同的SQL语句。

------



### **3. MySQL有哪些日志文件**



MySQL有多种重要的日志文件，它们用于不同的目的：

- **错误日志（Error Log）**：记录MySQL服务器的启动、关闭、运行中的错误、警告信息。这是诊断MySQL故障的首要文件。
- **二进制日志（Binary Log / Binlog）**：记录所有对数据库的**数据变更**操作，如`INSERT`、`UPDATE`、`DELETE`、`DDL`等。它不记录`SELECT`等查询操作。Binlog是MySQL主从复制和数据恢复（基于时间点的恢复）的基础。
- **查询日志（General Query Log）**：记录所有**接收到的SQL语句**，包括查询、写入、连接等。开启该日志会产生大量数据，通常只用于调试。
- **慢查询日志（Slow Query Log）**：记录执行时间超过指定阈值的SQL语句。它是数据库性能优化的重要工具。
- **重做日志（Redo Log）**：是InnoDB存储引擎特有的日志。它记录了**事务的物理变更**，用于保证事务的持久性（Durability）。即使系统崩溃，也可以通过Redo Log恢复到崩溃前的状态。
- **回滚日志（Undo Log）**：也是InnoDB特有。它记录了数据修改前的状态，用于事务回滚和MVCC（多版本并发控制）。

------



### **4. Redis有哪些持久化策略**



Redis提供了两种主要的持久化策略来防止数据丢失：

1. **RDB（Redis Database）**：**快照持久化**。它会在指定的时间间隔内，将内存中的所有数据进行快照存储，生成一个**RDB文件**（`dump.rdb`）。
   - **优点**：
     - 对性能影响小，因为在进行快照时，可以fork一个子进程来处理。
     - RDB文件紧凑，适合备份和灾难恢复。
   - **缺点**：
     - 可能造成数据丢失，因为它是定时快照，如果在两次快照之间Redis崩溃，那么这期间的数据就没了。
     - fork子进程会消耗一定的系统资源。
2. **AOF（Append-Only File）**：**增量持久化**。它以日志的形式记录所有**写命令**。Redis会将接收到的每个写命令追加到AOF文件末尾。
   - **优点**：
     - **数据更完整**：可以配置不同的同步策略（如每秒同步），数据丢失的风险很低。
     - AOF文件是可读的，方便进行日志分析和恢复。
   - **缺点**：
     - AOF文件通常比RDB文件大，恢复速度相对较慢。
     - 对性能有一定影响，因为每次写操作都需要记录。

------



### **5. 分布式锁redisson的底层原理 & 项目应用**



我的项目中用到了Redisson分布式锁，主要是为了解决**秒杀活动中的库存超卖**问题。

具体场景是：当用户下单时，需要先校验库存，再扣减库存。如果多个请求同时到达，可能会出现都校验通过但实际库存不足的情况，导致超卖。通过Redisson分布式锁，可以确保**同一时间只有一个线程**能够进行库存的校验和扣减操作。

**Redisson分布式锁的底层原理：**

Redisson的分布式锁是基于**Redis**实现的，它利用了Redis的**原子性**和**键空间**通知。其核心思想是：**一个锁就是一个Redis的键**。

1. **加锁**：
   - 当一个客户端A尝试获取锁时，Redisson会向Redis发送一个**原子命令（Lua脚本）**。
   - 这个脚本会检查锁键是否存在。如果不存在，则使用**`hset`命令**将锁键设为一个哈希表，并设置一个**过期时间**（防止死锁）。哈希表的字段是客户端ID+线程ID，值是1。
   - 如果锁键已存在，说明有其他客户端持有锁，客户端A会进入**自旋等待**或者通过**Pub/Sub**机制订阅锁释放事件。
2. **自动续期（Watchdog）**：
   - 为了防止因业务逻辑执行时间过长导致锁过期，Redisson引入了**Watchdog（看门狗）**机制。
   - 当一个客户端成功获取锁后，Redisson会启动一个后台线程。
   - 这个线程会每隔一段时间（默认是锁过期时间的**1/3**）检查锁是否还被当前客户端持有。
   - 如果持有，它会**自动延长锁的过期时间**。这样，只要客户端没有主动释放锁，并且进程没有宕机，这个锁就不会因为超时而自动释放。
3. **释放锁**：
   - 当客户端A的业务逻辑执行完毕后，会发送一个**Lua脚本**来释放锁。
   - 这个脚本会检查锁键是否存在，并且哈希表中的字段是否是当前客户端的ID。
   - 如果是，说明是持有锁的客户端来释放，则**`del`命令**删除锁键。
   - 如果不是，则不进行任何操作（防止误删）。

**为什么要用Lua脚本？** 因为Redis的许多操作并非原子性的，比如`GET`、`DEL`等。使用Lua脚本可以将**多个命令封装成一个原子操作**，保证了操作的**原子性**和**一致性**，避免了竞态条件。例如，在加锁和释放锁时，都需要先判断再操作，如果不用Lua脚本，就可能出现并发问题。



# 1111

### （1）雪花算法ID的组成及作用
雪花算法生成64位分布式ID，通常组成：
- **符号位（1位）**：固定为0，表示正数。
- **时间戳（41位）**：从自定义起始时间（如1970年）计算的毫秒级时间戳，用于排序和唯一性，确保ID随时间递增。
- **机器ID（10位）**：数据中心ID（5位）+工作节点ID（5位），用于区分不同机器/节点，避免冲突。
- **序列号（12位）**：同一毫秒内的自增序列，用于处理高并发下的唯一性。

每个部分作用：时间戳确保趋势递增，机器ID支持分布式环境，序列号处理并发。

解决时钟回拨：如果检测到时钟回拨（新时间 < 上次时间），常见方法是等待时钟追上（阻塞生成ID），或抛出异常拒绝生成；高级方案如借用序列号位或使用NTP同步时钟。

### （2）MySQL主从复制原理
主从复制基于binlog日志实现异步/半同步复制：
1. 主库（Master）执行写操作，记录到binlog（二进制日志）。
2. 从库（Slave）通过IO线程连接主库，拉取binlog并保存到relay log（中继日志）。
3. 从库的SQL线程读取relay log，重放SQL语句，实现数据同步。

原理确保读写分离，提升高可用；支持一主多从。半同步模式要求至少一个从库确认后，主库才返回成功。

### （3）MySQL日志文件
MySQL常见日志：
- **binlog**：二进制日志，记录数据变更，用于复制、恢复和审计。
- **redo log**：重做日志（InnoDB），记录事务物理修改，确保崩溃恢复（WAL机制）。
- **undo log**：回滚日志（InnoDB），记录事务前镜像，支持回滚和MVCC。
- **error log**：错误日志，记录启动/关闭/错误信息。
- **slow query log**：慢查询日志，记录执行慢的SQL，用于优化。
- **general log**：通用日志，记录所有操作（生产慎用，性能开销大）。
- **relay log**：中继日志，从库专用，用于主从复制。

### （4）Redis持久化策略
Redis持久化策略：
- **RDB（快照）**：定时将内存数据快照保存到磁盘（.rdb文件），如每分钟保存一次变化。优点：紧凑、恢复快；缺点：可能丢失最后一次快照后的数据。
- **AOF（日志）**：记录每个写命令到日志文件（.aof），恢复时重放命令。优点：数据丢失少（可配置fsync策略，如每秒同步）；缺点：文件大、恢复慢。
- **混合持久化**：Redis 4.0+，结合RDB和AOF，先RDB快照再增量AOF，平衡恢复速度和数据完整性。

默认无持久化（纯内存），生产需配置以防重启丢失数据。

### （5）项目中使用分布式锁场景及Redisson原理
项目中分布式锁常用于：如~~电商库存扣减（防止超卖）~~直接描述，不要说“超。。。”、分布式任务调度（确保单节点执行）、缓存一致性维护（避免并发更新）。

Redisson（Java Redis客户端）底层原理：基于Redis的SETNX（或SET with NX/EX）实现分布式锁，支持可重入、红锁等。
- **获取锁**：使用Lua脚本原子执行：如果key不存在，SET key value EX ttl（设置过期时间防死锁）；可重入时用Hash结构记录线程ID和重入计数。
- **释放锁**：Lua脚本检查线程ID匹配后，递减计数或DEL key。
- **红锁**：多节点Redis集群下，获取多数节点锁（N/2+1）以防单点故障。
- **Watch Dog**：自动续期机制，守护线程每ttl/3时间续期锁，防止任务超时释放。

额外点：雪花算法需注意机器ID唯一分配（如Zookeeper），否则冲突；MySQL主从延迟可能导致读从不一致，需读主或异步补偿；Redis AOF过大需定期rewrite；Redisson锁需处理网络分区，建议结合业务重试机制，避免死锁或饥饿。



