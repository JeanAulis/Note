# 9月1号



> [!caution]
>
> 流畅度，声音，自信



## （1）stream流你熟悉吗？说一下常用的api？

熟悉。常用的一些api有map()对一些对象进行映射，collect()收集Stream流，filter对一些元素进行过滤，sorted()排序，distinct()去重，forEach()遍历循环元素，limit()取前几个元素，skip()跳过前几个元素，count()统计个数，还有最大值最小值max()、min()。大概这些常用的api。

- map()对一些对象的属性做映射
- filter()：按条件过滤元素
- distinct()：去重（依赖 `hashCode` 和 `equals`  => 引出重写`hashCode`和`equals`方法）
- limit(n)：截取前n个
- skip(n)：跳过前n个
- collect()：收集stream流
- forEach()：循环遍历元素
- sorted()：排序
- count()、max()、min()

## （2)springBoot常用注解有哪些？spring常用注解有哪些？

SpringBoot的常用注解有：

`@SpringBootApplication`：它是标注SpringBoot启动类的注解

`@EnableAutoConfiguration`：自动注解的配置类

`@ConfigurationProperties`：配置绑定

`@SpringBootTest`：测试类

Spring的常用注解有

和IOC相关的：
@Component：注册：bean对象，一般用在方法类上
@Bean：注册bean对象，一般用在方法上
@Autowire：自动注入

和Web层相关的有: 
@Controller：标记控制器
@RequestMapping：映射请求资源和请求方法
@RestController(包含@Controller和@ResponseBody)：用于返回JSON给前端
@RequestBody：把请求体的JSON或者XML转换为java对象





## （3)说一下synchronized和ReentrantLock的区别？synchronized可以作用在哪些地方？锁的是什么？说一下synchronized的锁升级？可逆吗？

### `synchronized` 和 `ReentrantLock` 的区别

从来源方面来说，synchronized是JVM内置，ReentrantLock是来源于`java.util.concurrent.locks`包(JUC库)。

从公平性来说，synchronized是只支持非公平锁的，不能保证先等待的线程先获得锁，而ReentrantLock支持公平锁和非公平锁。

从中断响应的角度来说，synchronized等待锁的时候是不可中断的，ReentrantLock在等待锁时可使用`lockInterruptibly()`方法中断

synchronized在执行完同步块或者方法后会自动释放，ReentrantLock则需要使用unlock()手动释放，否则可能导致死锁

synchronized在尝试加锁的过程中，只能阻塞等待，可能会导致一直获取不到锁，变成僵尸进程，而ReentrantLock会使用tryLock()方法获取锁，这个方法有一个超时机制

> [!tip]
>
> 条件队列（Condition Queue）是 **并发编程里与锁（Lock）配合使用的一种等待/通知机制**。它的本质是一个“等待队列”，当线程在某个条件不满足时，就会被阻塞挂起，直到被其他线程显式唤醒。



### synchronized可以用在那些地方?锁的是什么？

可以作用在实例方法中，锁的是当前对象this；也可以作用在静态方法中，锁的是类的.class对象；也可以作用在代码块中，锁的是synchronized传入的对象

### 说一下synchronized的锁升级？可逆吗？

首先是**无锁状态**：当对象刚创建的时候，此时是**无锁状态**，没有线程竞争
				↓
当有一个线程访问的时候，锁会偏向该线程，也就是**偏向锁**
				↓
当有两个线程竞争，会升级为**轻量级锁**，使用CAS自旋尝试获取锁
				↓
当自旋失败或者竞争激烈时，会升级为**重量级锁**，线程会被阻塞挂起

锁的升级是不可逆的，主要的目的是减少锁管理和性能开销

> [!tip]
>
> 自旋（Spin）是 **多线程并发编程中的一种等待策略**，指的是线程在获取锁时，如果发现锁被占用，并不是立即阻塞挂起，而是在 **循环里反复尝试获取锁**，直到成功为止。

> [!NOte]
>
> 并发和并行
>
> | 特性         |            并发            |            并行            |
> | :----------- | :------------------------: | :------------------------: |
> | **核心概念** |      **处理**多个任务      |    **同时执行**多个任务    |
> | **硬件要求** |        单核即可实现        |    **必须多核**或多CPU     |
> | **微观视角** |      任务**交替执行**      |      任务**同时执行**      |
> | **关注点**   | 程序的设计与结构，避免阻塞 | 程序的执行速度，提升吞吐量 |
> | **比喻**     |  一个咖啡师同时做两杯咖啡  |   两个咖啡师各做一杯咖啡   |
>
> 并行是并发的特殊情况是真正的“同时”



synchronized在JDK1.6之后性能优化明显，它俩性能接近

| 对比点       | `synchronized`                              | `ReentrantLock`                                       |
| ------------ | ------------------------------------------- | ----------------------------------------------------- |
| **用法**     | 关键字，语法层面支持，JVM 内置              | 类库实现（`java.util.concurrent.locks` 包）           |
| **可重入性** | 可重入                                      | 可重入                                                |
| **公平性**   | 非公平（不能保证先等待的线程先获得锁）      | 可选公平/非公平（构造函数可指定）                     |
| **中断响应** | 等待锁时不可中断                            | 等待锁时可中断（`lockInterruptibly()`）               |
| **尝试加锁** | 只能阻塞等待                                | 可 `tryLock()` 尝试获取锁（超时机制）                 |
| **释放**     | 自动释放（执行完同步块/方法后自动释放）     | 必须手动释放（`unlock()`），否则可能死锁              |
| **条件队列** | 没有显式条件队列，只能 `wait()/notify()`    | 支持多个条件队列（`newCondition()`）                  |
| **性能**     | JDK1.6 之后性能优化明显（偏向锁、轻量级锁） | 更灵活，但加解锁需要更多代码，性能接近 `synchronized` |



------

总结一句话：

- `synchronized` 是 JVM 内置锁，简单可靠，支持锁升级（偏向→轻量→重量），不可逆。
- `ReentrantLock` 是手写锁，更灵活（公平、可中断、tryLock、多条件队列），但要手动释放。
- `synchronized` 锁的对象可以是 **对象实例**、**类对象**、**任意指定对象**。



## （4）你们公司的项目开发流程是怎么样的？

需求分析：原型文档，PRD文档

评估工期：根据接口数，入参，出参，是否有第三方接口

分析模块之间关系

表设计，接口设计

E-R图（实体-关系图）

接口文档

写代码

前后端联调

交给测试

有bug则退回修改，没有一般的话就可以准备上线了（严谨一些要在正式服务器上再进行测试）



## （5)你有没有在工作过程中和同事有分歧或者冲突的时候？有的话举一个例子？当时是怎么处理的？

> [!tip]
>
> 叼他



