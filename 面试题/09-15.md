# 9月15号

## （1）线程池的作用是什么？

1. **降低资源消耗**：线程池里的线程是可以重复利用的。一旦线程完成了某个任务，它不会立即销毁，而是回到池子里等待下一个任务。这就避免了频繁创建和销毁线程带来的开销。
2. **提高响应速度**：因为线程池里通常会维护一定数量的核心线程，任务来了之后，可以直接交给这些已经存在的、空闲的线程去执行，省去了创建线程的时间，任务能够更快地得到处理。
3. **提高线程的可管理性**：线程池提供了一套统一的机制来管理、监控和控制并发线程的数量。这有助于**防止因线程数量过多而导致的资源耗尽**，从而保证系统的稳定性和高可用性。



> [!CAUTION]
>
> 《阿里巴巴 Java 开发手册》强制线程池不允许使用 `Executors` 去创建，而是通过 `ThreadPoolExecutor` 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险



## （2）说一下线程池的工作原理？

> “先核心线程，再任务队列，最后临时线程”

1. **判断核心线程数：**
   - 线程池首先检查当前正在运行的线程数是否**小于** `corePoolSize`（核心线程数）。
   - **如果小于**，则立即创建一个新的**核心线程**来执行这个任务。
2. **尝试放入任务队列：**
   - **如果当前运行的线程数**已经达到或超过 `corePoolSize`，则不会立即创建新线程，而是尝试将任务放入 `workQueue`（任务队列）中。
   - **如果成功入队**，任务就在队列中等待，由空闲的核心线程来执行。
3. **创建临时线程（非核心线程）：**
   - **如果任务队列已满**，线程池会继续检查当前运行的线程数是否**小于** `maximumPoolSize`（最大线程数）。
   - **如果小于**，则创建一个新的**临时线程**来执行这个任务。
4. **执行拒绝策略：**
   - **如果当前线程数**已经达到 `maximumPoolSize`，并且任务队列也已满，线程池将无法处理新任务。
   - 此时，线程池会根据配置的 `handler`（拒绝策略）来决定如何处理，例如：抛出异常、直接丢弃任务、或让提交任务的线程自己来执行。

> 核心线程 -> 任务队列 -> 临时线程 -> 拒绝策略

![image-20250914221341995](./assets/image-20250914221341995.png)

## （3）线程池有哪些核心参数？

- `corePoolSize` : 这是线程池中**常驻的核心工作线程数量**。即使这些线程处于空闲状态，它们也不会被销毁（除非设置了 `allowCoreThreadTimeOut`）。当任务提交时，如果当前运行的线程数小于该值，线程池会优先创建新的核心线程来执行任务。
- `maximumPoolSize` : 这是线程池中**允许存在的最大线程数量**。当任务队列已满，并且当前运行的线程数小于此值时，线程池会创建新的**非核心线程（临时线程）**来处理任务。
- `workQueue`: 一个用于**存放待执行任务的阻塞队列**。当线程池中的线程数达到 `corePoolSize` 后，新提交的任务会被放入这个队列中排队等待执行。
- `keepAliveTime`:当线程池中的线程数量**超过 `corePoolSize`** 时，这些**非核心线程**在空闲等待新任务的`最长存活时间`。如果超过这个时间仍然没有新任务，该线程就会被销毁。
- `unit` : 这是一个枚举类型，定义了 `keepAliveTime` 参数的时间单位，如秒、毫秒等。
- `threadFactory` :executor 创建新线程的时候会用到。用于**创建新线程的工厂类**。我们可以通过它来自定义线程的创建，比如给线程指定有意义的名称、设置优先级等，方便后续排查问题。
- `handler` :拒绝策略。当线程池和任务队列都已满，无法再处理新任务时，线程池会**根据此策略来处理被拒绝的任务**，例如抛出异常或丢弃任务。



## （4）线程池的拒绝策略有哪些？

**`ThreadPoolExecutor` 拒绝策略定义:**

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，`ThreadPoolExecutor` 定义一些策略:

- `ThreadPoolExecutor.AbortPolicy`：抛出 `RejectedExecutionException`来拒绝新任务的处理。
- `ThreadPoolExecutor.CallerRunsPolicy`：调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- `ThreadPoolExecutor.DiscardPolicy`：不处理新任务，直接丢弃掉。
- `ThreadPoolExecutor.DiscardOldestPolicy`：此策略将丢弃最早的未处理的任务请求。

## （5）常用有哪些阻塞队列和怎么选择？

新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。

- `ArrayBlockingQueue`

​		**有界队列**：创建时必须指定固定容量。**这是它最核心的特点，用于防止任务无限堆积导致内存溢出（OOM）**。

​		**数组实现**：内部由数组存储，内存连续。

​		**一把锁**：生产（入队）和消费（出队）共用同一把锁，在高并发场景下吞吐量相对较低。

- 容量为 `Integer.MAX_VALUE` 的 `LinkedBlockingQueue`（无界队列）：`FixedThreadPool` 和 `SingleThreadExector` 。`FixedThreadPool`最多只能创建核心线程数的线程（核心线程数和最大线程数相等），`SingleThreadExector`只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。



> [!tip]
>
> 其他阻塞队列
>
> - `SynchronousQueue`（同步队列）：`CachedThreadPool` 。`SynchronousQueue` 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，`CachedThreadPool` 的最大线程数是 `Integer.MAX_VALUE` ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。
> - `DelayedWorkQueue`（延迟阻塞队列）：`ScheduledThreadPool` 和 `SingleThreadScheduledExecutor` 。`DelayedWorkQueue` 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。`DelayedWorkQueue` 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 `Integer.MAX_VALUE`，所以最多只能创建核心线程数的线程。



## （6）你在项目中怎么设置线程池的线程数？

- **计算密集型任务：** 这种任务大部分时间都在进行 CPU 运算，很少涉及 I/O 操作。如果线程数过多，会导致频繁的上下文切换，反而降低效率。通常建议将线程数设置为 **CPU 核心数 + 1**（或者 CPU 核心数）。例如，`Runtime.getRuntime().availableProcessors()`。
- **I/O 密集型任务：** 这种任务大部分时间都在等待 I/O 操作（如数据库查询、文件读写、网络请求等），CPU 占用率不高。为了充分利用 CPU 在等待 I/O 时的空闲时间，可以创建更多的线程。一个常用的经验公式是 **CPU 核心数 \* (1 + 线程等待时间 / 线程 CPU 时间)**。一个更简单的估算是 **CPU 核心数 \* 2**。



## （7）常用的线程池有哪些种类？

### FixedThreadPool：

核心线程数和最大线程数相等，线程数是固定的。它使用无界队列，任务数再多也不会创建超过核心线程数的线程。

### SingleThreadExecutor

只有一个线程的线程池。它确保所有任务都在单个线程中按顺序执行。可以看作是线程数为 1 的 `FixedThreadPool`。

### CachedThreadPool

核心线程数为 0，最大线程数为 `Integer.MAX_VALUE`。它使用同步队列，当有任务时会立即创建新线程（如果有空闲线程则复用），线程数会动态增长，空闲线程在 `keepAliveTime` 后会被销毁。

### ScheduledThreadPool

用于执行定时和周期性任务，它使用 `DelayedWorkQueue`，可以延迟或定时执行任务。

