# 10月14号

## 1. 怎么保证mq不丢消息？

消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。

- 生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。
- RabbitMQ 自身：持久化、集群、普通模式、镜像模式。
- RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。

> - 开启生产者确认机制,确保生产者的消息能到达队列
> - 开启持久化功能,确保消息未消费前在队列中不会丢失
> - 开启消费者确认机制为auto,由spring确认消息处理成功后完成ack
> - 开启消费者失败重试机制,并设置MessageRecoverer,多次重试失败后将消息投递到异常交换机然后路由到异常队列中保存,交由人工处理



## 2. 你们项目怎么解决mq的消息积压？

在我们项目（医疗设备健康平台）中，RabbitMQ 主要用于 IoT 设备数据采集和异步处理。设备端上报的数据全部先进入 MQ，由后端线程池异步消费和入库。

因为数据上报是持续高频、有时也存在网络波动，设备消息未及时上传导致堆积的，所以我们确实遇到过几次消息堆积问题。

当生产者发送消息的速度超过了消费者处理消息的速度,就会导致队列中的消息堆积,直到队列存储消息达到上限。

最早接收到的消息,可能就会成为死信,会被丢弃,这就是消息堆积问题。

消费者可以使用线程池，惰性队列，但是惰性队列不推荐

解决消息堆积有三种思路:

- 增加更多消费者,提高消费速度
- 在消费者内开启线程池加快消息处理速度
- 扩大队列容积,提高堆积上限



## 3. mq如何保证消费的有序性？

- 拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；
- 或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。



## 4. 你项目中怎么保证mq的消费幂等性？

订单创建后，通过 MQ 异步扣减库存。

MQ 的消费幂等性主要是防止同一条消息被重复消费导致重复入库或重复扣款。
RabbitMQ 的投递机制是“至少一次”，所以可能会出现重复消费。

**第一层是业务层面的唯一标识。**
 每一条消息都会带上一个全局唯一的业务 ID，比如订单号、设备编号加时间戳这类。消费端拿到消息之后，首先会去检查这条消息对应的业务是否已经处理过。比如这笔订单是不是已经扣过库存、这条设备数据是不是已经入过库，如果处理过了就直接跳过。

**第二层是用 Redis 做去重控制。**
 当消费者接收到消息后，会先往 Redis 里写一条标记，类似于“这条消息我已经在处理了”。Redis 本身支持原子操作，也就是说如果这条标记已经存在，那说明别的消费者或者当前线程已经处理过这条消息了，就不会再执行一次。这样即使 RabbitMQ 因为网络抖动或 ack 延迟又把消息投递了一遍，也不会造成重复处理。

最后，我这边采用的是**手动确认机制**。只有当整个业务流程（比如写数据库、更新状态）全部成功之后，才会向 MQ 发送 ack 确认。如果中途出现异常没有处理成功，就不 ack，让 RabbitMQ 重新投递。因为我们有 Redis 去重的机制，即使重复投递也不会重复执行业务逻辑。



## 5. 你有做过页面防抖吗？怎么实现？（比如在页面下单重复点了两次下单按钮）

有做过页面防抖，主要是在用户下单、支付这些关键按钮上。前端会通过防抖或者节流来限制用户短时间内重复点击，比如在点击下单按钮后会立即禁用按钮或设置短时间的延迟，这样前端层面可以先挡掉大部分重复请求。

但我这边更关注的是**后端的幂等性保障**，因为前端防抖只能减少重复提交，不能彻底避免，比如用户网络延迟、前端脚本被跳过等情况。后端会通过全局唯一的订单号或者请求流水号来做幂等控制，也就是说即使前端多点几次，最终服务端只会真正处理一次。

