# 10月14号

## 1. 怎么保证mq不丢消息？

消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。

- 生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。
- RabbitMQ 自身：持久化、集群、普通模式、镜像模式。
- RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。

> - 开启生产者确认机制,确保生产者的消息能到达队列
> - 开启持久化功能,确保消息未消费前在队列中不会丢失
> - 开启消费者确认机制为auto,由spring确认消息处理成功后完成ack
> - 开启消费者失败重试机制,并设置MessageRecoverer,多次重试失败后将消息投递到异常交换机然后路由到异常队列中保存,交由人工处理



## 2. 你们项目怎么解决mq的消息积压？

在我们项目（医疗设备健康平台）中，RabbitMQ 主要用于 IoT 设备数据采集和异步处理。设备端上报的数据全部先进入 MQ，由后端线程池异步消费和入库。

因为数据上报是持续高频、有时也存在网络波动，设备消息未及时上传导致堆积的，所以我们确实遇到过几次消息堆积问题。

当生产者发送消息的速度超过了消费者处理消息的速度,就会导致队列中的消息堆积,直到队列存储消息达到上限。

最早接收到的消息,可能就会成为死信,会被丢弃,这就是消息堆积问题。

消费者可以使用线程池，惰性队列，但是惰性队列不推荐

解决消息堆积有三种思路:

- 增加更多消费者,提高消费速度
- 在消费者内开启线程池加快消息处理速度
- 扩大队列容积,提高堆积上限



## 3. mq如何保证消费的有序性？

- 拆分多个 queue(消息队列)，每个 queue(消息队列) 一个 consumer(消费者)，就是多一些 queue (消息队列)而已，确实是麻烦点；
- 或者就一个 queue (消息队列)但是对应一个 consumer(消费者)，然后这个 consumer(消费者)内部用内存队列做排队，然后分发给底层不同的 worker 来处理。



## 4. 你项目中怎么保证mq的消费幂等性？

xxl-job也要保证幂等性



## 5. 你有做过页面防抖吗？怎么实现？（比如在页面下单重复点了两次下单按钮）

生成订单之前，先调用一个接口，生成一个唯一token，存在Redis（设置过期时间，久一点）和返回给前端，后续请求携带这个
