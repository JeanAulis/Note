# 10月14号

## 1. 怎么保证mq不丢消息？

消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。

- 生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。
- RabbitMQ 自身：持久化、集群、普通模式、镜像模式。
- RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制。

> - 开启生产者确认机制,确保生产者的消息能到达队列
> - 开启持久化功能,确保消息未消费前在队列中不会丢失
> - 开启消费者确认机制为auto,由spring确认消息处理成功后完成ack
> - 开启消费者失败重试机制,并设置MessageRecoverer,多次重试失败后将消息投递到异常交换机然后路由到异常队列中保存,交由人工处理



## 2. 你们项目怎么解决mq的消息积压？

在我们项目（医疗设备健康平台）中， IoT 设备数据采集和异步处理使用了RabbitMQ 。设备端上报的数据全部先进入 MQ，由后端线程池异步消费和入库。

因为数据上报是持续高频、有时也存在网络波动，设备消息未及时上传导致堆积的，所以我们确实遇到过几次消息堆积问题。

当生产者发送消息的速度超过了消费者处理消息的速度,就会导致队列中的消息堆积,直到队列存储消息达到上限。

最早接收到的消息,可能就会成为死信,会被丢弃,这就是消息堆积问题。

消费者可以使用线程池，惰性队列，但是惰性队列不推荐

解决消息堆积有三种思路:

- 增加更多消费者，提高消费速度
- 在消费者内开启线程池加快消息处理速度
- 扩大队列容积,提高堆积上限（可提可不提）



## 3. mq如何保证消费的有序性？

只安排一个消费者消费，~~预缓存，concurrency都为1~~

只有一个节点没有高可用，如果挂掉？-> 项目暂时没有这个场景，如果有消费者集群的话

使用**分区有序** - > 分多个队列，使用hash并取模，拆分成多个queue，每个队列一个消费者



## 4. 你项目中怎么保证mq的消费幂等性？

MQ 的消费幂等性主要是防止同一条消息被重复消费导致重复入库或重复扣款。

RabbitMQ 的投递机制是“至少一次”，所以可能会出现重复消费。


**生成唯一业务ID：** 在消息生产者侧，提前生成一个全局唯一的**业务ID**（比如订单ID、请求流水号），并将其嵌入到消息体中。


**消费者查重：** 消费者收到消息后，会利用这个业务ID，先去对应的业务数据库中进行查询。

- 如果数据库中**已存在**该ID的记录，说明该消息**已被成功处理过**，消费者直接返回，不做任何业务操作。
- 如果数据库中**不存在**，则继续执行正常的业务逻辑（如扣库存、插入订单）。

**考虑并发：** 为了在高并发集群环境下避免多个消费者同时查重（都查到空），可以在**查数据库之前**，使用**分布式锁**（以业务ID作为锁的键）来保证同一时刻只有一个消费者能处理该消息





## 5. 你有做过页面防抖吗？怎么实现？（比如在页面下单重复点了两次下单按钮）

有做过页面防抖，主要是在用户下单、支付这些关键按钮上。前端会通过防抖或者节流来限制用户短时间内重复点击，比如在点击下单按钮后会立即禁用按钮或设置短时间的延迟，这样前端层面可以先挡掉大部分重复请求。

但我这边更关注的是**后端的幂等性保障**，因为前端防抖，不能彻底避免，比如用户网络延迟、前端脚本被跳过等情况。后端会通过全局唯一的订单号或者请求流水号来做幂等控制，也就是说即使前端多点几次，最终服务端只会真正处理一次。
