# 9月17号

## （1）说一下java的三大特性

多态:多态是指同一个接口或方法在不同的对象上有不同的实现方式。包括方法重载（编译时多态）和方法重写（运行时多态）。

封装:封装是将数据（属性）和操作数据的方法（行为）结合在一起，并对外隐藏对象的内部实现细节。通过访问修饰符（public、private、protected）来控制对类成员的访问权限。

继承:继承允许一个类（子类/派生类）获得另一个类（父类/基类）的属性和方法，实现代码重用。Java使用`extends`关键字实现继承。

## （2）说一下数据库的三范式和反三范式

### 数据库三范式（3NF）



首先，我们来说说**三范式（3NF）**，也叫**数据库规范化（Normalization）**。

三范式的核心思想是**减少数据冗余，保证数据的一致性和完整性**。它就像是一种“数据瘦身”的方法，把数据分解到不同的表中，每张表只存储特定类型的信息。

三范式包括三个主要的规则：

**1. 第一范式（1NF）：原子性**

- 要求数据库表的每一列（字段）都是不可再分的最小数据单元。
- 简单来说，一个字段里不能再包含多个值。比如，一个`地址`字段不能同时存储`省`、`市`和`区`，而是应该拆分成独立的`省`、`市`、`区`字段。

**2. 第二范式（2NF）：消除部分依赖**

- 要求数据库表中的**非主键列**必须完全依赖于**主键**。

- 如果一个表的主键是联合主键（由多个字段组成），那么表中任何非主键字段都不能只依赖于主键的一部分。

  

**3. 第三范式（3NF）：消除传递依赖**

- 要求在2NF的基础上，**非主键列**之间不能有**传递依赖**。
- 简单来说，非主键列不能依赖于另一个非主键列。

优点：

- **减少数据冗余**：节省存储空间。
- **数据一致性高**：修改一处即可，避免了多处修改导致的数据不一致问题。
- **更新、插入和删除异常少**：更容易维护。

**三范式的缺点**：

- **查询效率低**：因为数据分散在多个表中，查询时需要进行多次**联接（JOIN）**操作，这会增加查询的开销。
- **模型过于复杂**：表太多，可能难以理解和维护。

------



### 反三范式（De-normalization）



既然三范式有缺点，那么**反三范式**就是为了解决这些问题而出现的。

**反三范式**的核心思想是**牺牲部分数据冗余，以换取查询性能的提升**。它不是完全不遵守范式，而是在遵循范式设计的基础上，为了特定的性能需求，故意引入一些冗余数据。

**常用的反三范式策略**：

- **增加冗余字段**：在A表里存储B表的数据，从而在查询时可以避免JOIN操作。
- **创建汇总表**：预先计算好一些聚合数据（如订单总额、用户总数等），并存放在单独的表中，以加快报表和统计查询。

**反三范式例子**：

- 为了加快`订单列表`的展示，我们可以在`订单表`中冗余存储`商品名称`、`客户姓名`等信息。
  - **三范式设计**：查询订单列表需要JOIN`商品表`和`客户表`。
  - **反三范式设计**：直接从`订单表`中查询，无需联接。

**反三范式的优点**：

- **查询性能高**：减少了多表联接，大大提高了查询速度。
- **简化查询逻辑**：一些复杂的查询变得更简单。

**反三范式的缺点**：

- **数据冗余**：增加了存储空间。
- **数据一致性风险**：当冗余数据源头发生变化时，需要额外机制来保证冗余数据同步更新，否则容易出现数据不一致。
- **更新、插入、删除操作开销增大**：需要同时修改多处数据。

------



### 总结



| 特性         | **三范式（3NF）**                  | **反三范式（De-normalization）**         |
| ------------ | ---------------------------------- | ---------------------------------------- |
| **目标**     | 减少数据冗余，保证数据一致性       | 牺牲冗余，提升查询性能                   |
| **设计原则** | **“瘦身”**，分解数据，消除冗余     | **“增肥”**，合并数据，引入冗余           |
| **主要优点** | 减少存储空间，高一致性，易于维护   | 查询速度快，查询逻辑简单                 |
| **主要缺点** | 查询效率低，多表联接开销大         | 数据冗余，更新维护困难，一致性风险高     |
| **适用场景** | 事务型应用（OLTP），写多读少的场景 | 报表、统计型应用（OLAP），读多写少的场景 |

在实际数据库设计中，通常不是非此即彼的选择。一个好的设计往往是**结合**三范式和反三范式：

- **写操作（插入、更新、删除）多的表**，倾向于使用**三范式**来保证数据一致性和完整性。
- **读操作（查询）频繁，且对性能要求极高的表或场景**，可以有选择性地使用**反三范式**来优化。

这是一种权衡的艺术，需要根据具体的业务需求和性能瓶颈来决定。

## （3）你们公司怎么管理分支的？平常是怎么解决冲突的？

我们公司的分支管理是基于Git Flow，有下面几个分支

**master/main分支**：生产环境代码，只包含稳定版本

**develop分支**：开发主分支，包含最新的开发进度

**feature分支**：功能开发分支，从develop分出，完成后合并回develop

**release分支**：发版分支，从develop分出，用于发版前的最后调试

**hotfix分支**：紧急修复分支，从master分出，修复后同时合并到master和develop



### 解决冲突：

优先进行沟通，从远端拉取代码，查看冲突标记，解决冲突部分，删除不需要的部分，保留需要的部分，测试好了之后commit代码，再推送到远端合代码

## （4）你有了解过我们公司吗？



## （5）你们项目qps和数据量有多大？

说是什么项目，

nginx日志文件可以统计QPS，AOP，拦截器，过滤器等等也可以；





数据量：一千万，不要说两千万，规避分库分表
