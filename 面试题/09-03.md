# 9月3号

## （1）说一下悲观锁和乐观锁的区别？还有行锁和表锁的区别？什么时候会上表锁？什么时候会上行锁？

### 悲观锁和乐观锁的区别？

从名字上面就能大概了解这两个锁的思想，他们两个的主要区别体现在对数据冲突的预期和处理方式，**悲观锁**的核心思想是认为数据总会被修改，所以在读取或者增删改数据的时候，先上锁再操作，阻塞其他事务对数据的修改；而**乐观锁**则是认为数据一般不会被修改，所以等提交更新的时候再检查数据是否被别的事务修改，有冲突就回滚或者重试。

再从并发性能方面来说，悲观锁适合写操作频繁，冲突概率高的业务，但是会导致阻塞，降低并发性能；而乐观锁适合读多写少，冲突概率低的业务，不会产生阻塞，但是冲突时重试会带来第一定的性能开销



> [!tip]
>
> 悲观锁和乐观锁是一种并发控制策略，常用在数据库和并发编程中。
>
> Java中synchronized和ReentrantLock都可以实现悲观锁，mysql中使用for update来实现；
>
> 乐观锁一般是通过版本号或者时间戳进行控制

> [!tip]
>
> 主要在加锁时机不同、给出建议，使用哪种

<img src="./assets/image-20250902205203017.png" alt="image-20250902205203017"  />

<img src="./assets/image-20250903220106913.png" alt="image-20250903220106913" style="zoom:80%;" />

![乐观锁](./assets/image-20250903160753414.png)

### 行锁和表锁的区别？什么时候会上表锁？什么时候会上行锁？

从细粒度上来说：行锁（Row Lock）只锁某一行或者几行的数据；而表锁锁住的是一整个表

从并发性能来说，行锁的并发性能高，只要操作的数据行不同，就不会阻塞等待，但是开销大（锁的数量多，加锁，释放锁，死锁检测的维护成本高）；表锁的并发性能低，一个事务对表加锁后，其他事务会被阻塞

>   [!tip]
>
> 行锁触发条件:
>
> 在行锁但查询的是没有索引条件，以及锁的行数超过阈值时，会升级为表锁



**行锁**：适合高并发、单行操作，性能更优

**表锁**：适合批量操作或低并发场景

**上锁性能**表锁性能高



<img src="./assets/image-20250902210349317.png" alt="image-20250902210349317" style="zoom: 67%;" />

![image-20250903160538618](./assets/image-20250903160538618.png)

<img src="./assets/image-20250903160406855.png" alt="image-20250903160406855" style="zoom:70%;" />

## （2）说一下mysql的存储引擎有哪些？说一下InnoDB和MyISAM的区别？

![image-20250903160108439](./assets/image-20250903160108439.png)

**Mysql 3.x-4.x(1995-2004):**

**MyISAM**：最早的存储引擎，简单高效，但功能有限，不支持事务和外键

**ISAM**(MyISAM的前身，已废弃)

---

**Mysql 5.0(2005-2010):**

**InnoDB**：由Innobase公司开发，支持事务和ACID特性，支持行级锁和外键

**Archive**：专门用于数据归档，高压缩比，只支持INSERT和SELECT

**CSV**：以CSV格式存储数据，方便数据导入导出

**Memory (HEAP)**：数据存储在内存中，访问速度极快

---

**Mysql 5.1(2008-2010):**

**Federated**：远程数据访问

**NDB Cluster**：MySQL集群存储引擎，支持分布式计算

---

之后的都是以InnoDB为主，默认引擎均为InnoDB

```mermaid
timeline
    title MySQL存储引擎发展历史
    section 1995-2004 (MySQL 3.x-4.x)
        MyISAM : 最早的存储引擎，简单高效<br>但功能有限，不支持事务和外键
        ISAM : MyISAM的前身，已废弃
    section 2005-2010 (MySQL 5.0)
        InnoDB : 由Innobase公司开发<br>支持事务和ACID特性<br>支持行级锁和外键
        Archive : 专门用于数据归档<br>高压缩比<br>只支持INSERT和SELECT
        CSV : 以CSV格式存储数据<br>方便数据导入导出
        Memory (HEAP) : 数据存储在内存中<br>访问速度极快
    section 2008-2010 (MySQL 5.1)
        Federated : 远程数据访问
        NDB Cluster : MySQL集群存储引擎<br>支持分布式计算
    section 之后版本
        以InnoDB为主 : 默认引擎均为InnoDB
```

### InnoDB和MyISAM的区别

事务处理方面：InnoDB支持ACID事务（引出ACID事务是什么？原子性、一致性、隔离性、持久性），MyISAM不支持事务。

行锁和表锁方面：InnoDB支持行级锁定和表级锁定，MyISAM只支持表级锁定。

外键约束方面（维护关联表的数据一致性）：InnoDB支持，MyISAM不支持。

崩溃恢复能力：InnoDB 支持崩溃恢复（redo Log），MyISAM 不支持。

全文索引方面：MyISAM的性能通常比InnoDB好（8.0后性能已经赶上甚至超过了，原因是上面那些区别）。

<img src="./assets/image-20250902214748056.png" alt="image-20250902214748056" style="zoom:67%;" />

## （3）什么是死锁？造成死锁的原因是什么？怎么解决死锁？

**死锁（Deadlock）** 是指两个或多个事务（或线程）在执行过程中，互相持有对方需要的资源，并且都在等待对方释放，最终导致这些事务永远无法继续执行下去的情况。

常见原因有以下几种：

1. **锁的获取顺序不一致**
   - 不同事务以不同的顺序请求锁，比如事务1 先锁 `id=1` 再锁 `id=2`，事务2 反过来。
2. **事务未提交，长时间持有锁**
   - 一个事务持有资源过久，阻塞其他事务，容易导致循环等待。
3. **资源竞争激烈**
   - 多个事务频繁访问相同的数据或索引，增加死锁概率。
4. **索引缺失导致锁范围扩大**
   - 例如 InnoDB 本来可以用行锁，但因为条件没有走索引，退化成表锁，死锁概率更高。
5. **应用层逻辑导致的循环依赖**
   - 比如转账、订单更新等业务逻辑里，事务之间相互依赖。

（1）避免死锁（预防）

- **统一加锁顺序**
  - 比如规定所有事务必须先锁定 `id 小的记录`，再锁定 `id 大的记录`。
- **尽量缩短事务时间**
  - 提交要快，减少锁持有时间。
- **减少锁范围**
  - 尽量使用行锁而不是表锁。
  - 查询条件带索引，避免全表扫描导致锁住整表。
- **分解大事务**
  - 把一个大事务拆分成多个小事务，减少资源争用。

（2）检测和解除死锁

**数据库自动检测**

- InnoDB 内置死锁检测机制，会选择一个“受害事务”回滚，从而打破僵局。

**应用层处理**

- 捕获死锁异常，重新执行事务。
- 一般写成 **重试机制**（例如重试 3 次）。

![image-20250903224427760](./assets/image-20250903224427760.png)

## （4）项目上线了吗？

上线了，在小程序内可以搜索到 =》打开准备好的小程序

## （5）你们有做单元测试吗？怎么做单元测试的？

基本步骤（经典的 **AAA 模式**：Arrange → Act → Assert）

1. **准备输入数据**（Arrange）
   - 模拟方法需要的参数和环境。
2. **执行被测方法**（Act）
   - 调用目标方法。
3. **断言结果**（Assert）
   - 验证结果是否符合预期。

测试工具

在 Java + Spring Boot 里，最常见的是：

- **JUnit 5**：单元测试框架（现在 Spring Boot 默认集成）。
- **AssertJ / Hamcrest**：增强断言语法。
- **Mockito**：Mock 框架，用于模拟依赖对象。
- **Spring Boot Test**：测试 Spring 上下文，支持集成测试。

![image-20250903230133789](./assets/image-20250903230133789.png)

