# 类加载器

### JVM 中的“类加载器”本质上是做什么的？

本质上，类加载器负责**把编译好的 .class 字节码加载进内存**，
并交给 JVM 建立对应的运行时结构（方法区里的类元信息 + 堆里的 Class 对象）。
类加载器负责把类的全限定名 → 转化成内存中的 Class 对象



### 类的生命周期

加载（Loading） → 链接（Linking：验证 Verification → 准备 Preparation → 解析 Resolution） → 初始化（Initialization） → 使用 → 卸载



### 类加载过程

加载（Loading） → 链接（Linking：验证 Verification → 准备 Preparation → 解析 Resolution） → 初始化（Initialization）



### 为什么要有双亲委派模型？

防止重复加载；
保证核心类的安全性（比如防止用户自己写一个假的 `java.lang.String`）。
还能**提高类加载效率**（因为一旦父加载器成功加载，下级就不用再找了）



### 什么时候会破坏双亲委派？举一个例子。

**Tomcat** and **Spring Boot**

Tomcat 要运行多个 web 应用（每个 `WEB-INF/lib` 下有自己版本的 jar 包），
如果所有应用都共用一个类加载器，可能会出现**版本冲突**。
Tomcat 让每个应用自己加载自己的类，**优先于父加载器**。

Spring Boot 的 fat jar（一个大 jar 包里嵌套了所有依赖 jar）
需要通过 **LaunchedURLClassLoader** 把内部 jar 加载出来。
因为这些 jar 不在标准 classpath 下，它必须自定义类加载逻辑，也就没法遵守标准的委派模型。



### 为什么要打破双亲委派？

双亲委派是安全的，但有时太“死板”。
框架为了**模块隔离**或**特殊加载逻辑**，不得不打破它。



### Tomcat 为什么要打破双亲委派？请用一句话总结。

为了让不同 Web 应用加载自己的类版本、互不干扰，Tomcat 设计了独立的类加载器并打破了双亲委派。



### 类加载的三个核心阶段分别是什么？每个阶段的作用简述一下。

| 阶段                         | 作用                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| **加载（Loading）**          | 通过类的全限定名找到 `.class` 文件，读取字节码到内存，创建 `Class` 对象。 |
| **链接（Linking）**          | 分三步：**验证**：检查字节码是否合法、安全；**准备**：为静态变量分配内存并设置**默认值**（不是代码里的初始值）；**解析（Resolution）**：将常量池中的符号引用替换为直接引用（内存地址）。 |
| **初始化（Initialization）** | 执行静态初始化块和静态变量赋值，完成类初始化。               |



### 类的“初始化”阶段，会执行哪些内容？

初始化是类生命周期中**第一次主动使用类**时触发的阶段。
 它主要做两件事：

- 执行类中所有的 `static {}` 代码块；
- 为静态变量赋值（是代码中的初始值，不是默认值）。



### 为什么 JVM 要设计出“双亲委派机制”？如果没有它，会出现什么问题？

“避免重复加载” 指的是防止**同一个类被不同类加载器重复加载进内存**，
 因为 JVM 会认为“类加载器 + 类的全限定名”才是唯一标识。

如果一个类被两个类加载器加载，JVM 会认为是**两个不同的类**，这会导致：

- 类型强转失败（`ClassCastException`）；
- 资源浪费；
- 安全风险（可能加载被篡改的类）。



### 类加载完成后，JVM 会创建一个 `Class` 对象。它主要用来做什么？

Class 对象是类在内存中的镜像，是反射的基础。反射、获取类信息、动态调用方法、访问字段都靠他。



### 自定义类加载器要重写哪个方法？

重写 `findClass(String name)` 方法。

你继承 `ClassLoader` 时，只需要重写 `findClass`，然后调用 `defineClass` 将字节数组转为 `Class` 对象即可。
 JVM 内部的 `loadClass()` 方法会自动调用它（除非被你改掉）。



### 为什么热加载要用新的类加载器？

JVM 不允许同一个类加载器重复加载同名类。

> 同一个类加载器 + 类名 = 唯一类定义。

> 全类路径 = 全限定名

所以想“重新加载一个类”，只能：

1. 创建一个新的类加载器；
2. 让它去加载更新后的字节码；
3. 再把旧的类加载器丢给 GC 回收。



### 类加载器委托顺序？

（Bootstrap → Ext → App → 自定义）

| 步骤 | 说明                                       |
| ---- | ------------------------------------------ |
| 1    | **Application ClassLoader** 收到请求       |
| 2    | 委托给 **Extension ClassLoader**           |
| 3    | Extension 委托给 **Bootstrap ClassLoader** |
| 4    | **Bootstrap 先尝试加载**（核心类）         |
| 5    | 如果 Bootstrap 找不到 → 返回失败           |
| 6    | 然后 **Extension 尝试加载**（扩展目录）    |
| 7    | Extension 找不到 → 返回失败                |
| 8    | 最后 **Application 自己加载**（classpath） |
| 9    | 还找不到 → 抛 `ClassNotFoundException`     |



# 运行时数据区

**线程共享的**：堆（Heap）、方法区（Method Area）

**线程私有的**：虚拟机栈（VM Stack）、本地方法栈（Native Stack）、程序计数器（PC）



### JVM 内存区域中，哪几个是**线程私有**的？

虚拟机栈（VM Stack）、本地方法栈（Native Stack）、程序计数器（PC）



### 方法区存的是什么内容？

类元信息、常量、静态变量、JIT 编译后的代码等。

类的结构（字段、方法、接口等）；运行时常量池；静态变量；方法字节码。



### 堆存的是什么内容？

对象实例和数组



> **堆**：存放对象实例、数组（动态分配，GC 管理）
>
> **方法区**：存放类信息、方法、静态变量、常量池等（类级别信息）
>
> 📍小记：堆放实例，方法区放类。



### 什么情况会出现 StackOverflowError？

递归调用太深会导致栈帧数量超出限制抛出 **`StackOverflowError`**（栈溢出），栈空间是有限的（默认 1MB 左右，可用 `-Xss` 调整）。

方法循环调用自己。

> 而“死循环”如果不产生新的方法调用，是不会导致栈溢出的，只会一直占 CPU。OOM



### 为什么 JDK8 去掉永久代（PermGen）改用元空间（Metaspace）？

JDK8 去掉永久代（PermGen），改用元空间（Metaspace）的原因是：

1. PermGen 容量固定，容易 `OutOfMemoryError: PermGen space`；
2. 无法自动扩容，调优麻烦；
3. 与不同平台实现不一致；
4. 把元空间放在本地内存（Native Memory），扩展更灵活。

>  JDK8 把永久代改为元空间带来的好处：
>
> - 元空间使用**本地内存**，不受 JVM 限制；
> - 可以自动扩容，不容易 OOM；
> - 调优更灵活，平台兼容性更好。



## 堆

### 为什么对象生命周期必须放在堆中？

因为对象的生命周期可能跨多个方法或线程，
栈是随方法退出就销毁的，堆是全局共享的，GC 统一管理。



### 为什么对象实例和数组放在堆？

- 因为对象的生命周期不确定，可能跨多个线程、方法。
- 而**栈是方法私有的，随方法调用结束即销毁**，无法保存跨方法的数据。
- 堆是共享的，GC 能统一管理它们的回收。



### 各分区占比（经典 HotSpot 默认）（G1）

| 区域               | 默认比例（大概） |
| ------------------ | ---------------- |
| 年轻代 (Young Gen) | 1/3              |
| 老年代 (Old Gen)   | 2/3              |

年轻代又细分为：

- Eden : Survivor0 : Survivor1 = **8 : 1 : 1**

**Eden**：新生代中的 Eden 区，用于分配新对象（年轻代的大部分空间）。

**Survivor0**（也称 S0）：新生代中的一个 Survivor 空间，用于存放从 Eden 复制过来的存活对象（Minor GC 后）。

**Survivor1**（也称 S1）：新生代中的另一个 Survivor 空间，与 S0 交替使用，存放 Minor GC 后的存活对象。



### “晋升”到老年代的条件

对象从新生区晋升到老年代通常满足以下条件：

1. **对象经历多次 Minor GC**（通常是 15 次，可通过 `-XX:MaxTenuringThreshold` 修改）；
2. **Survivor 区放不下了**（动态年龄判定）；
3. **大对象直接进入老年代**（如大数组，可调 `-XX:PretenureSizeThreshold`）；
4. **长期存活对象** 被判定为老年代对象。



### 为什么取消永久代？

**永久代（PermGen）** 在 JDK7 之前用于存放类信息、静态变量、常量池等。
 问题在于：

- 容量固定，默认只有几十 MB；
- 容易 `OutOfMemoryError: PermGen space`；
- 调优复杂、跨平台不一致。

于是：

> JDK 8 用 **元空间（Metaspace）** 替代了它，
>  把类元数据放在**本地内存（Native Memory）**中，更灵活、可自动扩容。



## 方法区

### 方法区和元空间区别

| 对比项     | PermGen（永久代）                 | Metaspace（元空间）                         |
| ---------- | --------------------------------- | ------------------------------------------- |
| 存储位置   | JVM 内存中                        | 本地内存（Native Memory）                   |
| 调优参数   | `-XX:PermSize`、`-XX:MaxPermSize` | `-XX:MetaspaceSize`、`-XX:MaxMetaspaceSize` |
| 容量问题   | 容易 OOM                          | 较少出现 OOM                                |
| 常量池位置 | 在方法区                          | JDK 8 移到堆中                              |





### 静态变量是什么？

> 静态变量是被 `static` 修饰的变量，属于类本身，而不是实例对象。

- 在**类加载时**（准备阶段）分配内存；
- 在**初始化阶段**赋初始值；
- 所有实例共享一份；
- 存储在**方法区（JDK 8 之前）或元空间/堆中（JDK 8 之后）**。



## 程序计数器

### 程序计数器记录的是什么？

记录当前线程**正在执行的字节码指令地址**。
执行完一条，会自动指向下一条（就像行号自动+1）。
如果执行 native 方法，PC 为空（Undefined）。



### 为什么不直接记录物理内存地址？

因为字节码是“虚拟指令”，由 JVM 解释器执行。
JVM 自己维护逻辑地址表，而不是直接操作物理地址。
所以用“字节码行号”更抽象、安全。



### 为什么程序计数器是线程私有的？

因为每个线程都独立执行字节码，切换线程时要能恢复正确的执行位置。
如果共享，会导致不同线程的执行状态混乱。



## 虚拟机栈

### 栈帧的作用

每当一个方法被调用，JVM 就创建一个栈帧（Stack Frame），
 里面保存：

- 局部变量表（方法参数、本地变量）；
- 操作数栈（计算用的中间结果）；
- 动态链接（解析常量池中符号引用）；
- 方法返回地址。



### 所有方法都会生成栈帧吗？

✅ 是的。
 无论是普通方法、构造方法、静态方法，都对应一个栈帧。（保存局部变量、操作数栈、返回地址等）方法执行完毕，栈帧弹出。



## 本地方法栈

区别于虚拟机栈：

- 虚拟机栈服务于 Java 方法；
- 本地方法栈服务于 native（C/C++）方法；
- 在 HotSpot 虚拟机中，它们实际上是合并实现的。



## 运行时常量池

属于方法区的一部分；

存放编译时生成的各种**符号引用、字面量、方法/字段名**；

运行时可以动态添加（如反射、动态代理）。



### 与字符串常量池的区别

| 对比项       | 运行时常量池                         | 字符串常量池       |
| ------------ | ------------------------------------ | ------------------ |
| 所在位置     | 方法区                               | 堆（JDK7 以后）    |
| 存储内容     | 所有编译期常量（符号引用、方法名等） | 仅字符串常量       |
| 可否动态添加 | ✅ 可以（`String.intern()`）          | 通过 intern() 添加 |
| 生命周期     | 随类加载存在                         | 运行期动态管理     |

> 字符串常量池其实是常量池的一个子集，专门存字符串。字符串常量池 ⊂ 运行时常量池



# 字节码执行引擎

执行引擎的工作就是：

> **把加载进来的字节码，变成机器能执行的指令。**

```
.class 文件 → 类加载器 → 运行时数据区 → 执行引擎执行字节码
```

JVM 执行引擎的三个组件

| 组件                      | 作用                         |
| ------------------------- | ---------------------------- |
| **解释器（Interpreter）** | 解释执行字节码               |
| **JIT 编译器**            | 编译热点代码为机器码         |
| **垃圾回收器（GC）**      | 回收堆中无用对象（下一节讲） |



> ### JVM 为什么同时使用解释器和 JIT？
>
> JVM（Java Virtual Machine）同时使用解释器（Interpreter）和 JIT（Just-In-Time）编译器是为了平衡启动速度和运行性能。解释器负责逐行解释字节码并立即执行，这使得程序启动更快，因为不需要提前编译整个代码。但解释器的执行效率较低，因为每次运行都需要重复解释。JIT 编译器则在运行时将频繁执行的字节码（热点代码）编译成本地机器码，提高执行速度，但这需要额外的时间来分析和编译。因此，解释器处理初始执行和冷代码，JIT 优化热点部分，实现“混合模式”（mixed mode），这样程序既能快速启动，又能在长期运行中获得高性能。如果只用解释器，性能差；只用 JIT（如 AOT 提前编译），启动慢。
>
> ### 什么是热点代码？JIT 怎么识别它？
>
> 热点代码（HotSpot Code）指的是程序中被频繁执行的部分，例如循环体、常用方法调用等，这些代码占用了大部分运行时间（根据 Pareto 原理，80% 的时间花在 20% 的代码上）。
>
> JIT 通过“方法计数器”和“回边计数器”来识别热点：
> - **方法计数器**：记录方法被调用的次数，当调用次数超过阈值（如默认 10000 次，可通过 -XX:CompileThreshold 配置）时，标记为热点。
> - **回边计数器**：针对循环，记录循环迭代（回边跳转）的次数，当超过阈值时，标记循环体为热点。
> JIT 在运行时监控这些计数器，一旦达到阈值，就将字节码异步编译成机器码，并替换原解释执行。HotSpot JVM（Oracle 的实现）以此得名，就是因为专注于热点优化。
>
> ### 方法内联是做什么的？为什么能提高性能？
>
> 方法内联（Method Inlining）是 JIT 的一种优化技术，它将方法调用的代码直接替换为被调用方法的方法体内容，而不是通过跳转执行方法调用。
>
> 例如，原代码：
> ```java
> public int add(int a, int b) {
>     return a + b;
> }
> 
> int result = add(1, 2);  // 方法调用
> ```
> 内联后相当于：
> ```java
> int result = 1 + 2;  // 直接替换
> ```
>
> 为什么能提高性能？
> - **减少方法调用开销**：正常方法调用涉及栈帧推送、参数传递、返回跳转等，这些操作消耗 CPU 周期。内联消除这些开销。
> - **启用进一步优化**：内联后，代码成为连续块，便于其他优化如常量折叠、死代码消除。
> - **改善分支预测和缓存命中**：连续代码减少跳转，提高 CPU 流水线效率和指令缓存利用率。
> 但内联不是无限的，受方法大小阈值限制（如默认 35 字节），过大方法不内联以避免代码膨胀。
>
> ### 什么是逃逸分析？它有什么优化作用？
>
> 逃逸分析（Escape Analysis）是 JIT 编译器的一项静态分析技术，用于检查对象的作用域是否“逃逸”出当前方法或线程。如果对象不逃逸（即只在方法内使用，不被返回、赋值给静态变量或传递给其他线程），则可以进行优化。
>
> 优化作用：
> - **栈上分配（Stack Allocation）**：不逃逸的对象可在栈上分配，而不是堆上。栈分配更快（无需 GC），对象随方法结束自动销毁，减少堆压力和垃圾回收开销。
> - **标量替换（Scalar Replacement）**：如果对象不逃逸且可分解为基本类型（如 int、double），JIT 可将其替换为这些标量变量，进一步消除对象创建开销。
> - **同步消除（Lock Elision）**：如果 synchronized 锁的对象不逃逸（无线程共享），JIT 可移除锁操作，减少同步 overhead。
> 例如，一个方法内创建的局部对象，如果不返回或共享，就可优化。这些优化显著提高性能，尤其在高频小对象创建场景中。逃逸分析在 HotSpot JVM 中默认启用，通过 -XX:+DoEscapeAnalysis 配置。





# GC（垃圾回收）算法/回收器 

- **对象存活判定**：JVM 采用**可达性分析**（从 **GC Roots** 出发可达=存活）。
  常见 **GC Roots**：<font style="color:red">栈上本地变量、方法区中的静态变量/常量、JNI 本地引用、正在执行的线程等。</font>
- **STW（Stop-The-World）**：为保证堆一致性，GC 某些阶段必须**全体线程暂停**。
- **Safepoint（安全点）**：只在有限指令点可停；编译器插“检查点”，到点才进入 STW。
- **分代假说**：大多数对象“朝生暮死”（年轻代回收频繁），少数活得久（老年代回收少）。
- **三色标记**（并发标记思想）：白（未标）→灰（标记到、待扫描）→黑（扫描完）。
  - 为避免并发漏标，需要**写屏障/读屏障**与**快照（SATB/增量更新）**协同。
- **Card Table / Remembered Set**：记录“老年代指向新生代”的写入，方便分代收集时只扫描相关卡页。
- **分配与晋升**：对象通常在 **Eden** 线性分配（TLAB bump-the-pointer），幸存多次→**Survivor**→**老年代**。
- **GC 事件类型**：
  - **Young/Minor GC**：仅年轻代。
  - **Old/Major GC**：老年代（术语有时与 Full 混用）。
  - **Full GC**：整堆+方法区一次性回收，通常最重。

---



### GC 判断对象活性靠“可达性分析”还是“引用计数”？

可达性分析



### 死亡对象判断方法

#### 引用计数法

给对象中添加一个引用计数器：

- 每当有一个地方引用它，计数器就加 1；
- 当引用失效，计数器就减 1；
- 任何时候计数器为 0 的对象就是不可能再被使用的。

**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。**

因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

#### 可达性分析算法

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

**哪些对象可以作为 GC Roots 呢？**

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象
- JNI（Java Native Interface）引用的对象





### **为什么“晋升失败（Promotion Failed）”容易引发 Full GC？你会首先检查哪两类设置/现象？**

晋升失败（Promotion Failed）指 Minor GC 后，**Survivor + 老年代都放不下要晋升的对象**。

这时 JVM 为了“腾空间”，会触发一次 **Full GC**（清理整个堆）。如果 Full GC 后仍不足，就会抛出 `OutOfMemoryError: Java heap space`。

检查方向：

> 堆参数：`-Xmx`、`-Xms`
>
> 年轻代/老年代比例：`-XX:NewRatio`、`-XX:SurvivorRatio`
>
> 晋升阈值：`-XX:MaxTenuringThreshold`



### Mixed GC 是什么（G1 特有）

**Mixed GC** 是 G1 回收策略中的一种模式。追求平衡回收与停顿。

- 它**同时回收年轻代和部分老年代的 Region**；
- 是介于 Minor GC（只收年轻代）与 Full GC（全堆）的“中间形态”；
- 触发条件：
  - 老年代占用超过阈值（默认 45%，`-XX:InitiatingHeapOccupancyPercent`）；
  - G1 认为通过部分老年代回收能达成“停顿目标”。



### CMS 的工作原理（4 阶段）

CMS（Concurrent Mark Sweep）是**老年代收集器**，目标是**低停顿**。

1️⃣ **初始标记（Initial Mark）**

- 标记 GC Roots 直接引用的对象；
- STW（很短）。

2️⃣ **并发标记（Concurrent Mark）**

- 从这些对象开始遍历引用；
- **与应用线程并发执行**。

3️⃣ **重新标记（Remark）**

- 修正并发标记期间产生的新引用变化；
- STW。

4️⃣ **并发清除（Concurrent Sweep）**

- 清理不可达对象；
- 与应用线程并发。

> **缺点：**
>
> - **碎片严重**（标记清除不整理）；
> - 若并发阶段内存耗尽 → “Concurrent Mode Failure” → 退化为 Full GC。



### G1 的工作原理（Region + Mixed GC）

G1（Garbage First） = 面向服务端的低延迟收集器。
特点：**Region 分区 + 可预测停顿时间**。

流程步骤（高层）：

1️⃣ **堆划分**

- 堆被分成若干 **Region（默认 2MB ~ 32MB）**，年轻代和老年代只是逻辑概念。

2️⃣ **Young GC**

- 回收 Eden + Survivor，类似复制算法。

3️⃣ **Concurrent Marking**

- 标记全堆可达对象；并发执行。

4️⃣ **Mixed GC**

- 回收全部年轻代 + 一部分“垃圾多”的老年代 Region。

5️⃣ **Full GC**

- 当并发失败或碎片太多时触发（少见）。



### GC 触发条件整理（HotSpot 常见）

| 类型               | 回收范围                  | 触发条件                                          |
| ------------------ | ------------------------- | ------------------------------------------------- |
| **Minor/Young GC** | 新生代（Eden+Survivor）   | Eden 区满（或 `System.gc()` 强制）                |
| **Old/Major GC**   | 老年代                    | 老年代空间不足、CMS 触发阈值                      |
| **Mixed GC**       | 年轻代 + 部分老年代（G1） | 老年代占用超过阈值（默认 45%）                    |
| **Full GC**        | 整个堆 + 元空间           | 老年代满、晋升失败、元空间不足、显式 GC、CMS 失败 |

> Eden 满 young，老代满 old，老代阈 mixed，全堆爆 full。