# 单例模式（Singleton Pattern）

单例模式是一种**创建型设计模式**，目的是让一个类在整个系统中**只有一个实例**，并且提供一个**全局访问点**。
它常用于全局资源的统一管理，比如配置对象、日志组件、线程池、数据库连接池等。

常见实现方式包括饿汉式、懒汉式、双重检查锁（DCL）、静态内部类和枚举单例。
企业开发中最推荐的是**静态内部类**和**双重检查锁（DCL）**两种写法，因为都能兼顾线程安全和懒加载性能。

项目中常见体现是：
Spring 中的 Bean 默认就是单例的；日志工具类、配置中心、全局缓存管理器等都是典型应用。

------



# 工厂方法模式（Factory Method Pattern）

工厂方法模式是一种**创建型模式**，它的核心思想是：**不直接 new 对象**，而是把“对象的创建逻辑”抽象到工厂中，由工厂来决定创建哪种产品。
这样可以在不改动客户端逻辑的情况下扩展新的产品类型，更符合开闭原则。

实现方式是：定义一个抽象工厂接口，每种具体产品都有一个对应的具体工厂类来负责实例化。
相比之下，简单工厂是一个类通过 if-else 来创建不同对象，而工厂方法是**一个产品对应一个工厂**，扩展性更强。

项目中的体现非常典型：
Spring 的 BeanFactory、FactoryBean 就是工厂方法模式的实现；当我们调用 ApplicationContext.getBean() 时，Spring 内部由工厂来负责 Bean 的创建。

------



# 建造者模式（Builder Pattern）

建造者模式的核心思想是：**将复杂对象的构建过程与它的表示分离**。
它让构建步骤可以灵活组合，适用于有多个可选参数或复杂组装步骤的对象，比如报表、文档、HTTP请求对象、或者构造配置复杂的实体类。

实现上一般包含四个角色：
Builder（定义建造步骤）、ConcreteBuilder（具体实现）、Director（指挥构建过程）和 Product（最终产品）。

项目中典型的体现有：
 Java 自带的 StringBuilder 就是典型例子；
Spring 中的 BeanDefinitionBuilder 用于动态创建 Bean；
Lombok 的 @Builder 注解更是直接把这个模式封装成注解形式。

------



# 责任链模式（Chain of Responsibility Pattern）

责任链模式是一种**行为型模式**，核心思想是：把多个处理逻辑对象串成一条链，请求沿着链依次传递，每个节点可以决定自己是否处理或交给下一个节点。
这样可以**解耦请求的发送者和处理者**，提高系统灵活性。

实现方式通常是定义一个抽象处理者接口，里面包含处理方法和指向下一个处理者的引用，形成链式传递。

项目中常见体现：

- Spring MVC 的过滤器（Filter）和拦截器（Interceptor）；
- Spring Security 的过滤器链；
- Netty 的 ChannelPipeline；
- 甚至 AOP 的执行链底层也体现了这种思想。